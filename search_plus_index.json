{"./":{"url":"./","title":"Introduction","keywords":"","body":"1. Introduction1. Introduction [danger] 提示 如果评论需要搭梯子！ "},"Grammar/":{"url":"Grammar/","title":"语法","keywords":"","body":""},"Grammar/enum.html":{"url":"Grammar/enum.html","title":"枚举","keywords":"","body":"在iOS中用两个宏来描述枚举：NS_ENUM、NS_OPTIONS，NS_ENUM多用于一般枚举，NS_OPTIONS则多用于带有移位运算的枚举。 typedef NS_ENUM(NSInteger, UITableViewCellStyle) { UITableViewCellStyleDefault, UITableViewCellStyleValue1, UITableViewCellStyleValue2, UITableViewCellStyleSubtitle }; typedef NS_OPTIONS(NSUInteger, Test) { TestA = 1 "},"Grammar/String.html":{"url":"Grammar/String.html","title":"字符串","keywords":"","body":"1. 字符串操作2. 字符串转字典3. 富文本1. 字符串操作 NSString *string = @\"123456789\"; NSLog(@\"%@\",[string substringWithRange:NSMakeRange(0, 4)]);//1234 NSLog(@\"%@\",[string substringWithRange:NSMakeRange(4, string.length-4)]);//56789 NSLog(@\"%@\",[string substringFromIndex:string.length - 4]);//6789 NSLog(@\"%@\",[string substringToIndex:6]);//123456 2. 字符串转字典 NSData *jsonData = [query dataUsingEncoding:NSUTF8StringEncoding]; NSDictionary *queryDic = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableContainers error:NULL]; 3. 富文本 NSFontAttributeName; //字体，value是UIFont对象 NSParagraphStyleAttributeName;//绘图的风格（居中，换行模式，间距等诸多风格），value是NSParagraphStyle对象 NSForegroundColorAttributeName;// 文字颜色，value是UIFont对象 NSBackgroundColorAttributeName;// 背景色，value是UIFont NSLigatureAttributeName; // 字符连体，value是NSNumber NSKernAttributeName; // 字符间隔 NSStrikethroughStyleAttributeName;//删除线，value是NSNumber NSUnderlineStyleAttributeName;//下划线，value是NSNumber NSStrokeColorAttributeName; //描绘边颜色，value是UIColor NSStrokeWidthAttributeName; //描边宽度，value是NSNumber NSShadowAttributeName; //阴影，value是NSShadow对象 NSTextEffectAttributeName; //文字效果，value是NSString NSAttachmentAttributeName;//附属，value是NSTextAttachment 对象 NSLinkAttributeName;//链接，value是NSURL or NSString NSBaselineOffsetAttributeName;//基础偏移量，value是NSNumber对象 NSUnderlineColorAttributeName;//下划线颜色，value是UIColor对象 NSStrikethroughColorAttributeName;//删除线颜色，value是UIColor NSObliquenessAttributeName; //字体倾斜 NSExpansionAttributeName; //字体扁平化 NSVerticalGlyphFormAttributeName;//垂直或者水平，value是 NSNumber，0表示水平，1垂直 "},"Grammar/Date.html":{"url":"Grammar/Date.html","title":"日期","keywords":"","body":"1. 两个时间对比2. NSDate to NSString3. NSString to NSDate1. 两个时间对比 两个时间需要进行对比时，可以使用下面的方法： - (NSDate *)earlierDate:(NSDate *)anotherDate; - (NSDate *)laterDate:(NSDate *)anotherDate; - (BOOL)isEqualToDate:(NSDate *)otherDate; - (NSComparisonResult)compare:(NSDate *)other; typedef NS_CLOSED_ENUM(NSInteger, NSComparisonResult) { NSOrderedAscending = -1L, // a b }; 2. NSDate to NSString -(NSDate*)getDate:(NSString*)dateString{ NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@\"yyyy-MM-dd\"]; return [dateFormatter dateFromString:dateString]; } 3. NSString to NSDate + (NSString *)datePicker_formatterWithDate:(NSDate *)date { NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@\"yyyy-MM-dd\"]; return [dateFormatter stringFromDate:date]; } "},"Grammar/Block.html":{"url":"Grammar/Block.html","title":"Block","keywords":"","body":"1. 声明1. 声明 "},"UI/":{"url":"UI/","title":"UI","keywords":"","body":""},"UI/UIView.html":{"url":"UI/UIView.html","title":"UIView","keywords":"","body":"1. 阴影1. 阴影 从图中可以看出:如果有圆角的UIView，阴影是无效的！ 因为一般设置圆角都设置了masksToBounds，补充一下两个属性： // 是指视图上的子视图,如果超出父视图的部分就截取掉 @property(nonatomic) BOOL clipsToBounds; // 却是指视图的图层上的子图层,如果超出父图层的部分就截取掉 @property BOOL masksToBounds; 如果想要圆角和阴影一起展示：可以不设置masksToBounds。 "},"UI/UIStackView.html":{"url":"UI/UIStackView.html","title":"UIStackView","keywords":"","body":"1. 创建2. 布局2.1. axis 布局方向（轴）2.2. distribution 子视图的分布2.2.1. Fill2.2.2. FillEqually2.2.3. FillProportionally2.2.4. EqualSpacing2.2.5. EqualCentering2.3. alignment2.3.1. UIStackViewAlignmentFill2.3.2. Leading、Top2.3.3. Trailing、Bottom2.3.4. Center2.3.5. FirstBaseline2.3.6. LastBaseline2.4. spacing2.5. baselineRelativeArrangement2.6. layoutMarginsRelativeArrangement2.7. 刷新布局3. 子视图操作4. 示例4.1. 点赞4.2. 给人打星评价4.3. 翻译5. 资料 系统：9.0以上。 UIStackView像一个容器，类似于UITableView，UICollectionView。 1. 创建 初始化方式： - (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER; - (instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER; - (instancetype)initWithArrangedSubviews:(NSArray *)views; @property(nonatomic,readonly,copy) NSArray *arrangedSubviews; UIStackView *sv = [LayoutUtils creatStackView]; [self addSubview:sv]; UIView *subView1 = [LayoutUtils createView]; UIView *subView2 = [LayoutUtils createView]; // 子View 实例加到 UIStackView 里 [sv addArrangedSubview:subView1]; [sv addArrangedSubview:subView2]; NSArray *arrangedSubviews = sv.arrangedSubviews; NSLog(@\"%@\",arrangedSubviews); /* 2020-06-12 09:39:59.898694+0800 MasonryExample[65963:3203047] ( \">\", \">\" ) */ UILabel *subLabel1 = [LayoutUtils fixedLabelWithText:@\"Sub1\"]; UILabel *subLabel2 = [LayoutUtils fixedLabelWithText:@\"Sub2\"]; UIStackView *sv = [[UIStackView alloc] initWithArrangedSubviews:@[subLabel1,subLabel2]]; [self addSubview:sv]; NSArray *arrangedSubviews = sv.arrangedSubviews; NSLog(@\"%@\",arrangedSubviews); /* 2020-06-12 09:42:19.734773+0800 MasonryExample[66066:3204972] ( \">\", \">\" ) */ 从结构上看@interface UIStackView : UIView，UIStackView是继承自UIView，对比下他们的关系： subviews：它的顺序实际上是图层覆盖顺序，也就是视图元素的z轴。 arrangedSubviews：它的顺序代表了 stack 堆叠的位置顺序，即视图元素的x轴和y轴。 如果一个元素没有被 addSubview，调用 arrangedSubviews 会自动 addSubview。 当一个元素被 removeFromSuperview ，则 arrangedSubviews也会同步移除。 当一个元素被 removeArrangedSubview， 不会触发 removeFromSuperview，它依然在视图结构中。 2. 布局 可以控制布局的几种方式， @property(nonatomic) UILayoutConstraintAxis axis; @property(nonatomic) UIStackViewDistribution distribution; @property(nonatomic) UIStackViewAlignment alignment; @property(nonatomic) CGFloat spacing; @property(nonatomic,getter=isBaselineRelativeArrangement) BOOL baselineRelativeArrangement; @property(nonatomic,getter=isLayoutMarginsRelativeArrangement) BOOL layoutMarginsRelativeArrangement; 2.1. axis 布局方向（轴） @property(nonatomic) UILayoutConstraintAxis axis; typedef NS_ENUM(NSInteger, UILayoutConstraintAxis) { UILayoutConstraintAxisHorizontal = 0, // 水平方向 UILayoutConstraintAxisVertical = 1 // 垂直方向 }; 2.2. distribution 子视图的分布 @property(nonatomic) UIStackViewDistribution distribution; typedef NS_ENUM(NSInteger, UIStackViewDistribution) { UIStackViewDistributionFill = 0,// 默认，轴方向上填充 UIStackViewDistributionFillEqually, //轴方向等宽或登高 UIStackViewDistributionFillProportionally,// 轴方向，比例分布 UIStackViewDistributionEqualSpacing,// 子视图间隔一致 UIStackViewDistributionEqualCentering, // 子视图中心距离一致 } 2.2.1. Fill UILayoutConstraintAxisHorizontal: UIStackView中的所有子视图的宽度等于UIStackView的宽。 当UIStackView中有1个子视图，则子视图的宽度就等于UIStackView的宽。 当UIStackView中有2个子视图，且优先级一样，则会拉伸或压缩某个子视图，使两个子视图的宽度之和等于UIStackView的宽。 当UIStackView中有2个子视图，且优先级不一样，则会按优先级从高到低设置子视图的位置，对优先级最低的子视图进行必要的拉伸或压缩。 UILayoutConstraintAxisVertical: UIStackView中的所有子视图的宽度等于UIStackView的高。 当UIStackView中有1个子视图，则子视图的高度就等于UIStackView的高。 当UIStackView中有2个子视图，且优先级一样，则会拉伸或压缩某个子视图，使两个子视图的高度之和等于UIStackView的高。 当UIStackView中有2个子视图，且优先级不一样，则会按优先级从高到低设置子视图的位置，对优先级最低的子视图进行必要的拉伸或压缩。 UIStackViewDistributionFill基本就是在轴方向上对子视图进行填充，类似对所有的子视图执行了下面两个方法： // 别挤我 - (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis; // 抱紧，类似于sizefit，不会根据父view长度变化 - (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis; 2.2.2. FillEqually UILayoutConstraintAxisHorizontal: 所有子视图在轴方向上等宽。 UILayoutConstraintAxisVertical: 所有子视图在轴方向上等高。 [subView1 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(40, 100))).priorityLow(); }]; [subView2 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(100, 80))).priorityLow(); }]; [subView3 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(70, 120))).priorityLow(); }]; [stackView makeConstraints:^(MASConstraintMaker *make) { make.left.equalTo(self.view); make.top.equalTo(@100); make.right.lessThanOrEqualTo(self.view); make.height.equalTo(@200); }]; 2.2.3. FillProportionally 该属性设置后会根据原先子视图的比例来拉伸或压缩子视图的宽或高，如果三个子视图原先设置的宽度是1：2：3，所以水平方向上显示时，会按照这个比例进行拉伸。 [subView1 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(1, 200))).priorityLow(); }]; [subView2 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(2, 200))).priorityLow(); }]; [subView3 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(3, 200))).priorityLow(); }]; [stackView makeConstraints:^(MASConstraintMaker *make) { make.left.equalTo(self.view); make.top.equalTo(@100); make.right.equalTo(self.view); make.height.equalTo(@200); }]; 2.2.4. EqualSpacing 该属性会保持子视图的宽高，所有子视图中间的间隔保持一致。 [subView1 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(40, 100))).priorityLow(); }]; [subView2 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(100, 80))).priorityLow(); }]; [subView3 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(70, 120))).priorityLow(); }]; [stackView makeConstraints:^(MASConstraintMaker *make) { make.left.equalTo(self.view); make.top.equalTo(@100); make.right.lessThanOrEqualTo(self.view); make.height.equalTo(@200); }]; - (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; UIView *subView1 = [LayoutUtils createView]; UIView *subView2 = [LayoutUtils createView]; UIView *subView3 = [LayoutUtils createView]; subView1.tag = 0; subView2.tag = 1; subView3.tag = 2; subView1.backgroundColor = UIColor.redColor; subView2.backgroundColor = UIColor.greenColor; subView3.backgroundColor = UIColor.blueColor; [subView1 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(130, 100))); }]; [subView2 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(130, 80))); }]; [subView3 makeConstraints:^(MASConstraintMaker *make) { // priorityLow() 是为了防止子视图总宽度超过，UIStackView 限制的宽度被挤压而产生的约束不合法。 make.size.equalTo(@(CGSizeMake(130, 120))).priorityLow(); }]; // 130 * 3 = 390 > 375 ，超过屏幕的宽度了，subView3 优先级比较低，所以首先会被挤压。 sv = [[UIStackView alloc] initWithArrangedSubviews:@[subView1,subView2,subView3]]; sv.alignment = UIStackViewAlignmentBottom; sv.distribution = UIStackViewDistributionEqualSpacing; sv.spacing = 30; [self.view addSubview:sv]; // 不设置宽度，让它宽度自适应 [sv makeConstraints:^(MASConstraintMaker *make) { make.left.equalTo(kPadding); make.top.equalTo(@100); make.right.lessThanOrEqualTo(kPadding); make.height.equalTo(200); }]; } -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ for (UIView *object in sv.arrangedSubviews) { if (object.tag == 1) { [object setHidden:YES]; // [object removeFromSuperview]; } } } 2.2.5. EqualCentering 该属性会控制所有子视图的中心之间的距离保持一致。 [subView1 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(40, 100))).priorityLow(); }]; [subView2 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(100, 80))).priorityLow(); }]; [subView3 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(70, 120))).priorityLow(); }]; [stackView makeConstraints:^(MASConstraintMaker *make) { make.left.equalTo(self.view); make.top.equalTo(@100); make.right.equalTo(self.view); make.height.equalTo(@200); }]; 2.3. alignment alignment : 控制子视图之间的间隔大小。在distribution属性设置为UIStackViewDistributionFill、UIStackViewDistributionFillEqually、UIStackViewDistributionFillProportionally值的时候，子视图是没有间隔的，我们就可以通过alignment属性来设置子视图之间的间距。 @property(nonatomic) UIStackViewAlignment alignment; typedef NS_ENUM(NSInteger, UIStackViewAlignment) { UIStackViewAlignmentFill, UIStackViewAlignmentLeading, UIStackViewAlignmentTop = UIStackViewAlignmentLeading, UIStackViewAlignmentFirstBaseline, UIStackViewAlignmentCenter, UIStackViewAlignmentTrailing, UIStackViewAlignmentBottom = UIStackViewAlignmentTrailing, UIStackViewAlignmentLastBaseline, } 2.3.1. UIStackViewAlignmentFill 尽可能铺满 2.3.2. Leading、Top UILayoutConstraintAxisVertical : UIStackViewAlignmentLeading 按 leading 方向对齐 UILayoutConstraintAxisHorizontal : UIStackViewAlignmentTop 按 top 方向对齐。 [subView1 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(40, 100))).priorityLow(); }]; [subView2 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(100, 80))).priorityLow(); }]; [subView3 makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(70, 120))).priorityLow(); }]; [stackView makeConstraints:^(MASConstraintMaker *make) { make.left.equalTo(self.view); make.top.equalTo(@100); make.right.equalTo(self.view); make.height.equalTo(@200); }]; 2.3.3. Trailing、Bottom UILayoutConstraintAxisVertical : UIStackViewAlignmentTrailing 按 trailing 方向对齐。 UILayoutConstraintAxisHorizontal : UIStackViewAlignmentBottom 按 bottom 方向对齐。 2.3.4. Center 居中对齐 2.3.5. FirstBaseline UILayoutConstraintAxisVertical : 垂直方向无效。 UILayoutConstraintAxisHorizontal : 水平方向有效，按首行基线对齐。 2.3.6. LastBaseline UILayoutConstraintAxisVertical : 垂直方向无效。 UILayoutConstraintAxisHorizontal : 水平方向有效，按文章底部基线对齐。 2.4. spacing // 设置元素之间的边距值 @property(nonatomic) CGFloat spacing; 2.5. baselineRelativeArrangement // 决定了垂直轴如果是文本的话，是否按照 baseline 来参与布局，默认 false。 @property(nonatomic,getter=isBaselineRelativeArrangement) BOOL baselineRelativeArrangement; 2.6. layoutMarginsRelativeArrangement // 如果打开则通过 layout margins 布局，关闭则通过 bounds，默认 false。 @property(nonatomic,getter=isLayoutMarginsRelativeArrangement) BOOL layoutMarginsRelativeArrangement; 2.7. 刷新布局 UIView *subView = [LayoutUtils createView]; [self.topStackView addArrangedSubview:subView]; [UIView animateWithDuration:0.25 animations:^{ [self.topStackView layoutIfNeeded]; }]; 3. 子视图操作 // 新增 - (void)addArrangedSubview:(UIView *)view; // 移除 - (void)removeArrangedSubview:(UIView *)view; // 插入 - (void)insertArrangedSubview:(UIView *)view atIndex:(NSUInteger)stackIndex; 4. 示例 4.1. 点赞 NSMutableArray *imageViewArray = [NSMutableArray array]; for (int i = 0; i 4.2. 给人打星评价 @interface UIKitExampleStackViewStarController () @property(nonatomic,strong) UIStackView *topStackView; @property(nonatomic,strong) UIStackView *bottomStackView; @end @implementation UIKitExampleStackViewStarController - (instancetype)init { self = [super init]; if (self) { self.title = @\"点击星星\"; self.view.backgroundColor = [UIColor whiteColor]; } return self; } - (void)viewDidLoad { [super viewDidLoad]; _topStackView = [[UIStackView alloc] init]; _topStackView.axis = UILayoutConstraintAxisVertical; _topStackView.alignment = UIStackViewAlignmentCenter; _topStackView.distribution = UIStackViewDistributionFillEqually; _topStackView.spacing = 6; _bottomStackView = [[UIStackView alloc] init]; _bottomStackView.alignment = UIStackViewAlignmentCenter; _bottomStackView.distribution = UIStackViewDistributionFillEqually; _bottomStackView.spacing = 6; [self.view addSubview:self.topStackView]; [self.view addSubview:self.bottomStackView]; [self.topStackView makeConstraints:^(MASConstraintMaker *make) { make.left.right.equalTo(self.view); make.top.equalTo(@100); make.height.equalTo(400); }]; [self.bottomStackView makeConstraints:^(MASConstraintMaker *make) { make.bottom.equalTo(self.view); make.centerX.equalTo(self.view); make.top.equalTo(self.topStackView.mas_bottom); }]; UILabel *titleLabel = [LayoutUtils fixedLabelWithText:@\"给个评价吧？\"]; UIView *logoView = [LayoutUtils createView]; UIButton *addStarButton = [LayoutUtils createButtonWithTitle:@\"Star\" target:self selector:@selector(addStar)]; UIButton *removeStarButton = [LayoutUtils createButtonWithTitle:@\"Remove Star\" target:self selector:@selector(removeStar)]; UIStackView *operation = [[UIStackView alloc] initWithArrangedSubviews:@[addStarButton,removeStarButton]]; operation.distribution = UIStackViewDistributionFillEqually; [self.topStackView addArrangedSubview:titleLabel]; [self.topStackView addArrangedSubview:logoView]; [self.topStackView addArrangedSubview:operation]; [logoView makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(50, 50))).priorityLow(); }]; [self.topStackView layoutIfNeeded]; } -(void)addStar{ UIView *starView = [LayoutUtils createView]; [self.bottomStackView addArrangedSubview:starView]; [starView makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(@(CGSizeMake(50, 50))).priorityHigh(); }]; starView.layer.cornerRadius = 25; starView.layer.masksToBounds = YES; starView.clipsToBounds = true; [UIView animateWithDuration:0.2 animations:^{ [self.bottomStackView layoutIfNeeded]; }]; } -(void)removeStar{ if (self.bottomStackView.arrangedSubviews.count >= 1) { [self.bottomStackView.arrangedSubviews.lastObject removeFromSuperview]; [UIView animateWithDuration:0.2 animations:^{ [self.bottomStackView layoutIfNeeded]; }]; } } @end 4.3. 翻译 5. 资料 掘金-UIStackView 入坑指南 iOS 9: Getting Started with UIStackView "},"UI/UITextField.html":{"url":"UI/UITextField.html","title":"UITextField","keywords":"","body":"1. 方法、属性2. 常用解决方案2.1. 添加监听2.2. 设置LeftView2.3. 设置输入单个字符之间的间距2.4. 限制输入的字符1. 方法、属性 // 输入、placeholder 位置 @property(nonatomic) NSTextAlignment textAlignment; typedef NS_ENUM(NSInteger, NSTextAlignment) { NSTextAlignmentLeft = 0, // Visually left aligned NSTextAlignmentCenter = 1, // Visually centered NSTextAlignmentRight = 2, // Visually right aligned NSTextAlignmentJustified = 3, // Fully-justified. The last line in a paragraph is natural-aligned. NSTextAlignmentNatural = 4 // Indicates the default alignment for script } 2. 常用解决方案 2.1. 添加监听 [self.textFiledInput addTarget:self action:@selector(test:) forControlEvents:UIControlEventAllEditingEvents]; -(void)test:(UITextField*)sender{ NSLog(@\"test%@\",sender.text); if (sender && sender.text && sender.text.length >= 4) { [sender resignFirstResponder]; } } 2.2. 设置LeftView UIView *paddingView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 5, 20)]; textField.leftView = paddingView; textField.leftViewMode = UITextFieldViewModeAlways; 或者重写UITextField的方法： @interface SATextField : UITextField @end @implementation SATextField // placeholder position - (CGRect)textRectForBounds:(CGRect)bounds { return CGRectInset(bounds, 10, 10); } // text position - (CGRect)editingRectForBounds:(CGRect)bounds { return CGRectInset(bounds, 10, 10); } @end 2.3. 设置输入单个字符之间的间距 Stack Overflow-How to set letter spacing of UITextField // 设置监听 [self.textFiledInput addTarget:self action:@selector(editing:) forControlEvents:UIControlEventAllEditingEvents]; // 操作监听 -(void)editing:(UITextField*)sender{ NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:sender.text]; [attributedString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:16] range:NSMakeRange(0, sender.text.length)]; [attributedString addAttribute:NSKernAttributeName value:@5 range:NSMakeRange(0, sender.text.length)]; if (sender.text.length > 3) { [attributedString addAttribute:NSKernAttributeName value:@5 range:NSMakeRange(0, 3)]; [attributedString addAttribute:NSKernAttributeName value:@0 range:NSMakeRange(3, sender.text.length-3)]; }else{ [attributedString addAttribute:NSKernAttributeName value:@5 range:NSMakeRange(0, sender.text.length)]; } sender.attributedText = attributedString; } // 限制输入字数 -(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string{ NSLog(@\"%s\",__FUNCTION__); NSString * str = [textField.text stringByReplacingCharactersInRange:range withString:string]; if (str.length > 4) { return false; } return YES; } 曾经做过的，短信验证码的逻辑: // 操作监听 -(void)editing:(UITextField*)sender{ NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:sender.text]; [attributedString addAttribute:NSFontAttributeName value:TextFieldFont range:NSMakeRange(0, sender.text.length)]; if (sender.text.length == 1) { CGFloat padding = (20- [self getSingleCharactorWidth:sender.text])/2; [self.inputTextField setValue:@(padding) forKey:@\"paddingLeft\"]; } for (NSInteger i = 0; i = sender.text.length) { }else{ NSString *firstChar = [sender.text substringWithRange:NSMakeRange(i, 1)]; NSString *secondChar = [sender.text substringWithRange:NSMakeRange(nextStringIndex, 1)]; CGFloat kern = 5 + (20- [self getSingleCharactorWidth:firstChar])/2 + (20- [self getSingleCharactorWidth:secondChar])/2; [attributedString addAttribute:NSKernAttributeName value:@(kern) range:NSMakeRange(i, 1)]; } } sender.attributedText = attributedString; } 计算的逻辑图： 2.4. 限制输入的字符 // 限制输入字数 -(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string{ // 监听到 return 收起键盘 if ([string isEqualToString:@\"\\n\"]) { [textField resignFirstResponder]; return NO; } if (!string || string.length 6) { return NO; } if (![@\"0123456789Xx\" containsString:string]) { return NO; } return YES; } "},"UI/UIImage.html":{"url":"UI/UIImage.html","title":"UIImage","keywords":"","body":"1. UIImage指定图片可变区域（slicing)1.1. 视图化操作1.2. 代码操作1. UIImage指定图片可变区域（slicing) 1.1. 视图化操作 1.2. 代码操作 - (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets; - (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode; typedef NS_ENUM(NSInteger, UIImageResizingMode) { UIImageResizingModeTile = 0, // 平铺模式，通过重复显示UIEdgeInsets指定的矩形区域来填充图片 UIImageResizingModeStretch = 1, // 拉伸模式，通过拉伸UIEdgeInsets指定的矩形区域来填充图片 }; 示例： UIEdgeInsets insets = UIEdgeInsetsMake(30,47,15,10); UIImage *image =[[UIImage imageNamed:@\"icons8-folder\"] resizableImageWithCapInsets:insets resizingMode:UIImageResizingModeStretch]; UIImageView *imageView=[[UIImageView alloc]initWithFrame:CGRectZero]; imageView.image=image; [self.view addSubview:imageView]; imageView.frame = CGRectMake(10, 100, 250, 100); "},"UI/table.html":{"url":"UI/table.html","title":"表格","keywords":"","body":"1. 设置分割线宽度2. 拖拽表格取消键盘1. 设置分割线宽度 // 设置系统分割屏幕左右间隔15pt if([self.tableView respondsToSelector:@selector(setCellLayoutMarginsFollowReadableWidth:)]) { if (@available(iOS 9.0, *)) { self.tableView.cellLayoutMarginsFollowReadableWidth = NO; } } if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) { [self.tableView setSeparatorInset:UIEdgeInsetsMake(0, 15, 0, 15)]; } if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) { if (@available(iOS 8.0, *)) { [self.tableView setLayoutMargins:UIEdgeInsetsMake(0, 15, 0, 15)]; } } 2. 拖拽表格取消键盘 // 拖拽表格取消键盘 self.tableView.keyboardDismissMode = UIScrollViewKeyboardDismissModeOnDrag; "},"wwdc/":{"url":"wwdc/","title":"WWDC记录","keywords":"","body":""},"wwdc/wwdc2020.html":{"url":"wwdc/wwdc2020.html","title":"WWDC2020","keywords":"","body":"1. 资料1. 资料 Apple-wwdc20 "},"Github/":{"url":"Github/","title":"Github库","keywords":"","body":""},"Github/Masonry.html":{"url":"Github/Masonry.html","title":"Masonry","keywords":"","body":"1. 官方推荐布局的位置2. 一些属性的讲解2.1. activate、deactivate2.2. NSArray2.3. greaterThanOrEqualTo、lessThanOrEqualTo2.4. inset、sizeOffset、offset、centerOffset2.5. insets2.6. firstBaseline、lastBaseline2.7. leading、trailing、left、right2.8. animator2.8.1. 示例：动态添加控件3. 优先级4. layoutMarginsGuide5. safeAreaLayoutGuide6. 系统布局相关6.1. UIView7. 动画7.1. 安全范围内移动控件7.2. 更新动画7.3. 约束放到数组中7.4. 移除-更新约束8. Masonry 代码示例8.1. 布局使用结构体8.1.1. insets的链式使用8.2. 约束8.3. 等宽高布局8.4. 混合布局8.5. Masonry Aspect8.6. 给Masonry添加Debug8.7. UILabel布局8.7.1. 多行UILabel8.8. UILabel自适应宽度/高度8.9. UIScrollView布局8.9.1. 垂直方向8.9.2. 水平方向8.10. Array的Button数组8.11. layoutMargins8.12. mas_distributeViewsAlongAxis8.13. 多行label的约束问题?8.14. multipler、dividedBy8.15. UITableView8.15.1. UITableViewDataSource8.15.2. MASTableViewNormalCell8.15.3. UITableView8.16. 外部的部分靠内部支撑8.17. UIButton自适应宽度8.18. UITableView九宫格8.19. UITableView 折叠、展开9. 资料仓库地址 1. 官方推荐布局的位置 @implementation DIYCustomView - (id)init { self = [super init]; if (!self) return nil; // --- Create your views here --- self.button = [[UIButton alloc] init]; return self; } // tell UIKit that you are using AutoLayout + (BOOL)requiresConstraintBasedLayout { return YES; } // this is Apple's recommended place for adding/updating constraints - (void)updateConstraints { // --- remake/update constraints here [self.button remakeConstraints:^(MASConstraintMaker *make) { make.width.equalTo(@(self.buttonSize.width)); make.height.equalTo(@(self.buttonSize.height)); }]; //according to apple super should be called at end of method [super updateConstraints]; } - (void)didTapButton:(UIButton *)button { // --- Do your changes ie change variables that affect your layout etc --- self.buttonSize = CGSize(200, 200); // tell constraints they need updating [self setNeedsUpdateConstraints]; } -(void)layoutSubviews{ [super layoutSubviews]; } @end 2. 一些属性的讲解 2.1. activate、deactivate 2.2. NSArray make.height.equalTo(@[view1.mas_height, view2.mas_height]); make.height.equalTo(@[view1, view2]); make.left.equalTo(@[view1, @100, view3.right]); 2.3. greaterThanOrEqualTo、lessThanOrEqualTo greaterThanOrEqualTo : 小于等于。 lessThanOrEqualTo : 大于等于。 //width >= 200 && width 2.4. inset、sizeOffset、offset、centerOffset inset和insets的用法差不多,值为正数时往视图内部偏移，负数则往远离视图的方向偏移。 make.size.equalTo(view2).sizeOffset(CGSizeMake(10, -20)); make.center.equalTo(view2).centerOffset(CGPointMake(0, 100)); 2.5. insets [self.yellowView mas_makeConstraints:^(MASConstraintMaker *make) { make.left.equalTo(self.view).with.offset(10); make.top.equalTo(self.view).with.offset(10); make.right.equalTo(self.view).with.offset(-10); make.bottom.equalTo(self.view).with.offset(-10); }]; // 通过insets简化设置内边距的方式 [self.blueView mas_makeConstraints:^(MASConstraintMaker *make) { // 下、右不需要写负号，insets方法中已经为我们做了取反的操作了。 make.edges.equalTo(self.view).with.insets(UIEdgeInsetsMake(10, 10, 10, 10)); }]; 2.6. firstBaseline、lastBaseline firstBaseline、lastBaseline就是基线对齐则。 2.7. leading、trailing、left、right leading与left，trailing与right 在正常情况下是等价的。 2.8. animator // 是否在修改约束时通过动画代理 @property (nonatomic, copy, readonly) MASConstraint *animator; // 如果OS支持就激活一个NSLayoutConstraint，否则就调用install - (void)activate; // 销毁前面安装或者激活的NSLayoutConstraint - (void)deactivate; //创建一个NSLayoutConstraint并将它添加到合适的view上 - (void)install; //移除以前安装的NSLayoutConstraint - (void)uninstall; 2.8.1. 示例：动态添加控件 static UIEdgeInsets padding; static CGFloat height = 100; static int num = 0; @interface MASExampleAutoAddView() @property (nonatomic, strong) UIView *superView; @property (nonatomic, strong) UIView *bottomView; @property (nonatomic, weak) MASConstraint *bottomConstraint; @end @implementation MASExampleAutoAddView - (id)init { self = [super init]; if (!self) return nil; padding = UIEdgeInsetsMake(10, 10, 10, 10); self.superView = [LayoutUtils createView]; [self addSubview:self.superView]; [self.superView makeConstraints:^(MASConstraintMaker *make) { make.left.right.top.mas_equalTo(padding); }]; UIButton *tapButton = [LayoutUtils createButtonWithTitle:@\"Add\" target:self selector:@selector(clickButton:)]; [self.superView addSubview:tapButton]; [tapButton makeConstraints:^(MASConstraintMaker *make) { make.left.right.top.mas_equalTo(padding); self.bottomConstraint = make.bottom.mas_equalTo(padding);//记录下这个约束对象 make.height.equalTo(@(height)); }]; self.bottomView = tapButton; UIView *bottomView = [LayoutUtils createView]; [self.superView addSubview:bottomView]; [bottomView makeConstraints:^(MASConstraintMaker *make) { make.left.right.mas_equalTo(padding); make.top.mas_equalTo(self.superView.mas_bottom).mas_equalTo(padding); make.height.mas_equalTo(@(height)); }]; return self; } -(void)clickButton:(UIButton*)sender{ [self.bottomConstraint uninstall];//卸载旧的底部约束 num += 1; UILabel *label = [LayoutUtils fixedLabelWithText:[NSString stringWithFormat:@\"控件%d\", num]]; [self.superView addSubview:label]; [label makeConstraints:^(MASConstraintMaker *make) { make.left.right.mas_equalTo(padding); make.top.equalTo(self.bottomView.mas_bottom).mas_equalTo(padding); self.bottomConstraint = make.bottom.equalTo(self.superView.mas_bottom).mas_equalTo(padding);//添加新的底部约束 make.height.equalTo(@(height)); }]; self.bottomView = label; } @end 3. 优先级 priority(value) : 手动设置优先级的数值，优先级最大数值是1000。priority(200) priorityLow() : 约束优先级-低。 priorityMedium() : 约束优先级-中。priorityMedium()=500 priorityHigh() : 约束优先级-高。 // 别挤我 - (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis; // 抱紧，类似于sizefit，不会根据父view长度变化 - (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis; @interface MASTableViewPriorityCell : MASTableViewBasicCell @property (strong, nonatomic) UILabel *leftLabel; // 必须显示完整 @property (strong, nonatomic) UILabel *middleLabel; // 可以显示全就显示，显示不全展示(XXXX...) @property (strong, nonatomic) UIButton *rightButton; // rightView 在 middleLabel 的右边，完全显示，不能超过右边屏幕 @end @implementation MASTableViewPriorityCell -(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{ if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) { self.selectionStyle = UITableViewCellSelectionStyleNone; self.leftLabel = [LayoutUtils fixedLabelWithText:@\"0万\"]; [self.contentView addSubview:self.leftLabel]; [self.leftLabel makeConstraints:^(MASConstraintMaker *make) { make.left.top.bottom.equalTo(kPadding); }]; self.middleLabel = [LayoutUtils fixedLabelWithText:@\"\"]; self.middleLabel.numberOfLines = 1; self.middleLabel.textAlignment = NSTextAlignmentLeft; [self.contentView addSubview:self.middleLabel]; [self.middleLabel makeConstraints:^(MASConstraintMaker *make) { make.top.bottom.equalTo(kPadding); make.left.equalTo(self.leftLabel.mas_right).inset(kPadding.right); }]; self.rightButton = [LayoutUtils createButtonWithTitle:@\"置顶\" target:self selector:@selector(buttonClick:)]; [self.contentView addSubview:self.rightButton]; [self.rightButton makeConstraints:^(MASConstraintMaker *make) { make.top.bottom.equalTo(kPadding); make.left.equalTo(self.middleLabel.mas_right).inset(kPadding.right); make.right.lessThanOrEqualTo(self.contentView).inset(kPadding.right); }]; //宽度不够时，可以被压缩 [self.middleLabel setContentCompressionResistancePriority:UILayoutPriorityFittingSizeLevel forAxis:UILayoutConstraintAxisHorizontal]; // 抱紧 [self.middleLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal]; //不可以被压缩，尽量显示完整 [self.leftLabel setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal]; } return self; } -(void)updateData{ self.leftLabel.text = [NSString stringWithFormat:@\"%@万\",self.cellData.playCount]; self.middleLabel.text = self.cellData.content; } @end 4. layoutMarginsGuide UIView 有一个UIEdgeInsets 类型的属性 layoutMargins。它表示一个视图的内容和它四个边界之间的空隙。 UIView 的 layoutMarginsGuide 属性其实是 layoutMargins 的另一种表现形式，可用于创建布局约束。layoutMarginsGuide 是一个 只读 属性。 5. safeAreaLayoutGuide 在 iOS 11 时，苹果提出了 Safe Area 的概念。因为 iOS 11 搭载的 iPhone X 取消了 Home 键，要为操作保留一些空间，这正好把原来的 Navigation Bar, Status Bar, Tab Bar 包含在里面。safeAreaLayoutGuide 属性正是伴随 Safe Area 出现的。safeAreaLayoutGuide 是一个 只读 属性。 Masonry 1.1.0 最新版本对safeAreaLayoutGuide是会crach的。 6. 系统布局相关 6.1. UIView + (BOOL)requiresConstraintBasedLayout{ return YES; } @property(class, nonatomic, readonly) BOOL requiresConstraintBasedLayout; /// update constraints now so we can animate the change - (void)updateConstraintsIfNeeded; /// this is Apple's recommended place for adding/updating constraints - (void)updateConstraints; - (BOOL)needsUpdateConstraints; /// tell constraints they need updating - (void)setNeedsUpdateConstraints; /// 告知页面需要更新，但是不会立刻开始更新。执行后会立刻调用 layoutSubviews - (void)setNeedsLayout; /// 告知页面布局立刻更新。所以一般都会和 setNeedsLayout 一起使用。如果希望立刻生成新的 frame 需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。 - (void)layoutIfNeeded; /// 系统重写布局 - (void)layoutSubviews; 用法： - (void)updateConstraints { // Layout code here... [super updateConstraints]; } -(void)tap{ [self setNeedsUpdateConstraints]; [self updateConstraintsIfNeeded]; [UIView animateWithDuration:0.4 animations:^{ [self layoutIfNeeded]; }]; } // iOS系统最低配为iOS8.0 __IPHONE_OS_VERSION_MIN_REQUIRED >= 80000 7. 动画 7.1. 安全范围内移动控件 @interface MASExampleTouchMoveView() @property (nonatomic, strong) MASConstraint *leftConstraint; // 保存左边的约束，用于在移动时调整位置 @property (nonatomic, strong) MASConstraint *topConstraint; // 保存顶部的约束，用于在移动时调整位置 @end @implementation MASExampleTouchMoveView - (id)init { self = [super init]; if (!self) return nil; UILabel *label = [LayoutUtils fixedLabelWithText:@\"Move Me\"]; [self addSubview:label]; [label makeConstraints:^(MASConstraintMaker *make) { self.leftConstraint = make.centerX.equalTo(self.mas_left).with.offset(50).priorityHigh(); self.topConstraint = make.centerY.equalTo(self.mas_top).with.offset(50).priorityHigh(); // 边界条件约束，保证内容可见，优先级1000 make.left.greaterThanOrEqualTo(kPadding); make.right.lessThanOrEqualTo(kPadding); make.top.greaterThanOrEqualTo(kPadding); make.bottom.lessThanOrEqualTo(kPadding); }]; return self; } -(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event{ UITouch *touch = [[event allTouches] anyObject]; CGPoint touchLocation = [touch locationInView:self]; NSLog(@\"%@\",NSStringFromCGPoint(touchLocation)); self.leftConstraint.offset = touchLocation.x; self.topConstraint.offset = touchLocation.y; } @end 7.2. 更新动画 @implementation MASExampleTotalUpdateAnimateView - (id)init { self = [super init]; if (!self) return nil; self.superView = [LayoutUtils createView]; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(onTap)]; [self.superView addGestureRecognizer:tap]; [self addSubview:self.superView]; self.sonView = [LayoutUtils createView]; [self addSubview:self.sonView]; [self setNeedsUpdateConstraints]; return self; } -(void)updateConstraints{ [self.superView mas_updateConstraints:^(MASConstraintMaker *make) { make.left.top.equalTo(kPadding); make.right.equalTo(kPadding); if (self.isExpanded) { make.bottom.equalTo(kPadding); } else { make.bottom.mas_equalTo(-300); } }]; [self.sonView mas_updateConstraints:^(MASConstraintMaker *make) { make.center.equalTo(self.superView); // 这里使用优先级处理 // 设置其最大值为250，最小值为90 if (!self.isExpanded) { make.width.height.mas_equalTo(100 * 0.5).priorityLow(); } else { make.width.height.mas_equalTo(100 * 3).priorityLow(); } make.width.height.lessThanOrEqualTo(@250);// 最大值为250 make.width.height.greaterThanOrEqualTo(@90);// 最小值为90 }]; [super updateConstraints]; } -(void)onTap{ self.isExpanded = !self.isExpanded; [self setNeedsUpdateConstraints]; [self updateConstraintsIfNeeded]; [UIView animateWithDuration:0.4 animations:^{ [self layoutIfNeeded]; }]; } @end 7.3. 约束放到数组中 - (id)init { self = [super init]; if (!self) return nil; [blueView addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(update)]]; [blueView setUserInteractionEnabled:YES]; UIView *superview = self; int padding = self.padding = 10; UIEdgeInsets paddingInsets = UIEdgeInsetsMake(self.padding, self.padding, self.padding, self.padding); self.animatableConstraints = NSMutableArray.new; [greenView mas_makeConstraints:^(MASConstraintMaker *make) { [self.animatableConstraints addObjectsFromArray:@[ make.edges.equalTo(superview).insets(paddingInsets).priorityLow(), make.bottom.equalTo(blueView.mas_top).offset(-padding), ]]; make.size.equalTo(redView); make.height.equalTo(blueView.mas_height); }]; [redView mas_makeConstraints:^(MASConstraintMaker *make) { [self.animatableConstraints addObjectsFromArray:@[ make.edges.equalTo(superview).insets(paddingInsets).priorityLow(), make.left.equalTo(greenView.mas_right).offset(padding), make.bottom.equalTo(blueView.mas_top).offset(-padding), ]]; make.size.equalTo(greenView); make.height.equalTo(blueView.mas_height); }]; [blueView mas_makeConstraints:^(MASConstraintMaker *make) { [self.animatableConstraints addObjectsFromArray:@[ make.edges.equalTo(superview).insets(paddingInsets).priorityLow(), ]]; make.height.equalTo(greenView.mas_height); make.height.equalTo(redView.mas_height); }]; return self; } -(void)update{ int padding = self.isChangePadding ? 100 : self.padding; UIEdgeInsets paddingInsets = UIEdgeInsetsMake(padding, padding, padding, padding); for (MASConstraint *constraint in self.animatableConstraints) { constraint.insets = paddingInsets; } [UIView animateWithDuration:1 animations:^{ [self layoutIfNeeded]; } completion:^(BOOL finished) { self.isChangePadding = !self.isChangePadding; }]; } 7.4. 移除-更新约束 + (BOOL)requiresConstraintBasedLayout{ return YES; } - (void)updateConstraints { [self.movingButton remakeConstraints:^(MASConstraintMaker *make) { make.width.equalTo(@(100)); make.height.equalTo(@(100)); if (self.topLeft) { make.left.equalTo(self.left).with.offset(10); make.top.equalTo(self.top).with.offset(10); } else { make.bottom.equalTo(self.bottom).with.offset(-10); make.right.equalTo(self.right).with.offset(-10); } }]; [super updateConstraints]; } - (void)toggleButtonPosition { self.topLeft = !self.topLeft; // tell constraints they need updating [self setNeedsUpdateConstraints]; // update constraints now so we can animate the change [self updateConstraintsIfNeeded]; [UIView animateWithDuration:0.4 animations:^{ [self layoutIfNeeded]; }]; } 8. Masonry 代码示例 makeConstraints: : 添加约束。 updateConstraints: : 更新约束、亦可添加新约束。 remakeConstraints: : 重置之前的约束。 mas_distributeViewsAlongAxis:withFixedSpacing:leadSpacing:tailSpacing: mas_distributeViewsAlongAxis:withFixedItemLength:leadSpacing:tailSpacing: multipler : 表示约束值为约束对象的乘因数。 dividedBy : 表示约束值为约束对象的除因数。 8.1. 布局使用结构体 make.center.equalTo(CGPointMake(0, 50)); make.size.equalTo(CGSizeMake(200, 100)); make.edges.equalTo(superview).insets(UIEdgeInsetsMake(self.padding, self.padding, self.padding, self.padding)); make.edges.mas_equalTo(UIEdgeInsetsMake(10, 0, 10, 0)); make.left.mas_equalTo(view).mas_offset(UIEdgeInsetsMake(10, 0, 10, 0)); 8.1.1. insets的链式使用 UIEdgeInsets padding = UIEdgeInsetsMake(15, 10, 15, 10); [greenView mas_makeConstraints:^(MASConstraintMaker *make) { // chain attributes make.top.and.left.equalTo(superview).insets(padding); // which is the equivalent of // make.top.greaterThanOrEqualTo(superview).insets(padding); // make.left.greaterThanOrEqualTo(superview).insets(padding); make.bottom.equalTo(blueView.mas_top).insets(padding); make.right.equalTo(redView.mas_left).insets(padding); make.width.equalTo(redView.mas_width); make.height.equalTo(@[redView, blueView]); }]; [redView mas_makeConstraints:^(MASConstraintMaker *make) { // chain attributes make.top.and.right.equalTo(superview).insets(padding); make.left.equalTo(greenView.mas_right).insets(padding); make.bottom.equalTo(blueView.mas_top).insets(padding); make.width.equalTo(greenView.mas_width); make.height.equalTo(@[greenView, blueView]); }]; [blueView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(greenView.mas_bottom).insets(padding); // chain attributes make.left.right.and.bottom.equalTo(superview).insets(padding); make.height.equalTo(@[greenView, redView]); }]; 8.2. 约束 @property (nonatomic, strong, readonly) MASConstraint *left; @property (nonatomic, strong, readonly) MASConstraint *top; @property (nonatomic, strong, readonly) MASConstraint *right; @property (nonatomic, strong, readonly) MASConstraint *bottom; @property (nonatomic, strong, readonly) MASConstraint *leading; @property (nonatomic, strong, readonly) MASConstraint *trailing; @property (nonatomic, strong, readonly) MASConstraint *width; @property (nonatomic, strong, readonly) MASConstraint *height; @property (nonatomic, strong, readonly) MASConstraint *centerX; @property (nonatomic, strong, readonly) MASConstraint *centerY; @property (nonatomic, strong, readonly) MASConstraint *baseline; @property (nonatomic, strong, readonly) MASConstraint *firstBaseline; @property (nonatomic, strong, readonly) MASConstraint *lastBaseline; @property (nonatomic, strong, readonly) MASConstraint *leftMargin; @property (nonatomic, strong, readonly) MASConstraint *rightMargin; @property (nonatomic, strong, readonly) MASConstraint *topMargin; @property (nonatomic, strong, readonly) MASConstraint *bottomMargin; @property (nonatomic, strong, readonly) MASConstraint *leadingMargin; @property (nonatomic, strong, readonly) MASConstraint *trailingMargin; @property (nonatomic, strong, readonly) MASConstraint *centerXWithinMargins; @property (nonatomic, strong, readonly) MASConstraint *centerYWithinMargins; @property (nonatomic, strong, readonly) MASConstraint *edges; @property (nonatomic, strong, readonly) MASConstraint *size; @property (nonatomic, strong, readonly) MASConstraint *center; 8.3. 等宽高布局 不管父视图如何布局，子视图内部都是等宽高的布局。 UIView *superview = self; int padding = 10; [greenView makeConstraints:^(MASConstraintMaker *make) { make.top.greaterThanOrEqualTo(superview.top).offset(padding); make.left.equalTo(superview.left).offset(padding); make.bottom.equalTo(blueView.top).offset(-padding); make.right.equalTo(redView.left).offset(-padding); make.width.equalTo(redView.width); make.height.equalTo(redView.height); make.height.equalTo(blueView.height); }]; //with is semantic and option [redView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(superview.mas_top).with.offset(padding); //with with make.left.equalTo(greenView.mas_right).offset(padding); //without with make.bottom.equalTo(blueView.mas_top).offset(-padding); make.right.equalTo(superview.mas_right).offset(-padding); make.width.equalTo(greenView.mas_width); make.height.equalTo(@[greenView, blueView]); //can pass array of views }]; [blueView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(greenView.mas_bottom).offset(padding); make.left.equalTo(superview.mas_left).offset(padding); make.bottom.equalTo(superview.mas_bottom).offset(-padding); make.right.equalTo(superview.mas_right).offset(-padding); make.height.equalTo(@[greenView.mas_height, redView.mas_height]); //can pass array of attributes }]; 8.4. 混合布局 UIView *lastView = self; for (int i = 0; i 8.5. Masonry Aspect - (instancetype)initWithFrame:(CGRect)frame { self = [super initWithFrame:CGRectZero]; multipliedBy = 1; if (self) { // Create views self.topView = [[UIView alloc] initWithFrame:CGRectZero]; self.topInnerView = [[UIView alloc] initWithFrame:CGRectZero]; self.bottomView = [[UIView alloc] initWithFrame:CGRectZero]; self.bottomInnerView = [[UIView alloc] initWithFrame:CGRectZero]; [self.topInnerView addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(update)]]; [self.topInnerView setUserInteractionEnabled:YES]; // Set background colors UIColor *blueColor = [UIColor colorWithRed:0.663 green:0.796 blue:0.996 alpha:1]; [self.topView setBackgroundColor:blueColor]; UIColor *lightGreenColor = [UIColor colorWithRed:0.784 green:0.992 blue:0.851 alpha:1]; [self.topInnerView setBackgroundColor:lightGreenColor]; UIColor *pinkColor = [UIColor colorWithRed:0.992 green:0.804 blue:0.941 alpha:1]; [self.bottomView setBackgroundColor:pinkColor]; UIColor *darkGreenColor = [UIColor colorWithRed:0.443 green:0.780 blue:0.337 alpha:1]; [self.bottomInnerView setBackgroundColor:darkGreenColor]; // 顶部(topView)、底部(bottomView) View 高度均分。 [self addSubview:self.topView]; [self.topView mas_makeConstraints:^(MASConstraintMaker *make) { make.left.right.and.top.equalTo(self); }]; [self addSubview:self.bottomView]; [self.bottomView mas_makeConstraints:^(MASConstraintMaker *make) { make.left.right.and.bottom.equalTo(self); make.top.equalTo(self.topView.mas_bottom); make.height.equalTo(self.topView); }]; // Inner views are configured for aspect fit with ratio of 3:1 [self.topView addSubview:self.topInnerView]; [self.topInnerView mas_makeConstraints:^(MASConstraintMaker *make) { // 宽度是其自身高度的三倍 make.width.equalTo(self.topInnerView.mas_height).multipliedBy(multipliedBy); // 宽度和高度都不超过其父视图的宽度和高度 make.width.and.height.lessThanOrEqualTo(self.topView); // 宽度和高度等于其父视图的宽度 优先级低 make.width.and.height.equalTo(self.topView).with.priorityLow(); make.center.equalTo(self.topView); }]; [self.bottomView addSubview:self.bottomInnerView]; [self.bottomInnerView mas_makeConstraints:^(MASConstraintMaker *make) { //高度等于其自身宽度的3倍 make.height.equalTo(self.bottomInnerView.mas_width).multipliedBy(3); // 宽度和高度都不超过其父视图的宽度和高度 make.width.and.height.lessThanOrEqualTo(self.bottomView); // 宽度和高度等于其父视图的宽度 优先级低 make.width.and.height.equalTo(self.bottomView).with.priorityLow(); make.center.equalTo(self.bottomView); }]; } return self; } +(BOOL)requiresConstraintBasedLayout{ return YES; } -(void)updateConstraints{ [self.topInnerView remakeConstraints:^(MASConstraintMaker *make) { //1. 确定坐标 make.center.equalTo(self.topView); //2. 宽度和高度等于其父视图的宽度 优先级低 make.width.and.height.equalTo(self.topView).with.priorityLow(); //3. 宽度是其自身高度的三倍 make.width.equalTo(self.topInnerView.mas_height).multipliedBy(self->multipliedBy);// width=height*4 ==> width/height=4/1 //4. 宽度和高度都不超过其父视图的宽度和高度 make.width.and.height.lessThanOrEqualTo(self.topView); }]; [super updateConstraints]; } -(void)update{ multipliedBy += 1; NSLog(@\"%f\",multipliedBy); [self setNeedsUpdateConstraints]; [self updateConstraintsIfNeeded]; [UIView animateWithDuration:0.4 animations:^{ [self layoutIfNeeded]; }]; } 8.6. 给Masonry添加Debug 当约束冲突时，打印的日志比较难定位是哪些控件的约束或者说是哪条约束，Masonry已经给我们提供了相关的方法:MASAttachKeys()、给约束设置key。 greenView.mas_key = @\"greenView\"; MASAttachKeys(greenView, redView, blueView, superview); [blueView mas_makeConstraints:^(MASConstraintMaker *make) { //you can also attach debug keys to constaints make.edges.equalTo(@1).key(@\"ConflictingConstraint\"); //composite constraint keys will be indexed make.height.greaterThanOrEqualTo(@5000).key(@\"ConstantConstraint\"); make.top.equalTo(greenView.mas_bottom).offset(padding); make.left.equalTo(superview.mas_left).offset(padding); make.bottom.equalTo(superview.mas_bottom).offset(-padding).key(@\"BottomConstraint\"); make.right.equalTo(superview.mas_right).offset(-padding); make.height.equalTo(greenView.mas_height); make.height.equalTo(redView.mas_height).key(@340954); //anything can be a key }]; // 添加Debug前 \"= 5000>\", \"\", \"\", \"\", \"= MASExampleDebuggingView:0x7f82ef422490.top + 10>\" // 添加Debug后 \"= 5000>\", \"\", \"\", \"\", \"= MASExampleDebuggingView:superview.top + 10>\" 8.7. UILabel布局 8.7.1. 多行UILabel static UIEdgeInsets const kPadding = {10, 10, 10, 10}; - (id)init { self = [super init]; if (!self) return nil; self.longLabel.lineBreakMode = NSLineBreakByTruncatingTail; self.longLabel.text = @\"Bacon ipsum dolor sit amet spare ribs fatback kielbasa salami, tri-tip jowl pastrami flank short loin rump sirloin. Tenderloin frankfurter chicken biltong rump chuck filet mignon pork t-bone flank ham hock.\"; [self.longLabel makeConstraints:^(MASConstraintMaker *make) { make.left.equalTo(self.left).insets(kPadding); make.top.equalTo(self.top).insets(kPadding); }]; [self.shortLabel makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.longLabel.lastBaseline); make.right.equalTo(self.right).insets(kPadding); }]; return self; } - (void)layoutSubviews { [super layoutSubviews]; // for multiline UILabel's you need set the preferredMaxLayoutWidth // you need to do this after [super layoutSubviews] as the frames will have a value from Auto Layout at this point // stay tuned for new easier way todo this coming soon to Masonry CGFloat width = CGRectGetMinX(self.shortLabel.frame) - kPadding.left; width -= CGRectGetMinX(self.longLabel.frame); self.longLabel.preferredMaxLayoutWidth = width; // need to layoutSubviews again as frames need to recalculated with preferredLayoutWidth [super layoutSubviews]; } 8.8. UILabel自适应宽度/高度 @interface MASExampleMulLabelAutoSizeView() @property (nonatomic, strong) UILabel *label; @end @implementation MASExampleMulLabelAutoSizeView - (id)init { self = [super init]; if (!self) return nil; self.label = [LayoutUtils fixedLabelWithText:@\"最近是用Masonry自动布局UILabel的时候，;这些东西之后，label还是没有换行。最近是用Masonry自动布局UILabel的时候，\"]; self.label.textAlignment = NSTextAlignmentLeft; [self addSubview:self.label]; [self.label mas_makeConstraints:^(MASConstraintMaker *make) { make.top.mas_equalTo(100); make.left.mas_equalTo(15); }]; UIButton *button = [LayoutUtils createButtonWithTitle:@\"添加文字\" target:self selector:@selector(clickButton:)]; [self addSubview:button]; [button mas_makeConstraints:^(MASConstraintMaker *make) { make.top.mas_equalTo(self.label.mas_bottom).mas_offset(20); make.centerX.mas_equalTo(self); make.height.mas_equalTo(50); make.width.mas_lessThanOrEqualTo(300); }]; return self; } -(void)clickButton:(UIButton*)sender{ self.label.text = [self.label.text stringByAppendingString:@\"Masonry自动布局YYLabel\"]; } -(void)layoutSubviews{ [super layoutSubviews]; self.label.preferredMaxLayoutWidth = CGRectGetWidth(self.frame) - 30; } @end 8.9. UIScrollView布局 在使用Masonry对UIScrollView设置约束后，contentSize属性就不管用了，需要通过Masonry的规则在scrollView中添加一个contentView,其它的子视图全部添加到 contentView 上，让contentView来撑起UIScrollview的contentSize。 8.9.1. 垂直方向 @interface MASExampleScrollView () @property (strong, nonatomic) UIScrollView* scrollView; @end @implementation MASExampleScrollView - (id)init { self = [super init]; if (!self) return nil; UIScrollView *scrollView = UIScrollView.new; self.scrollView = scrollView; scrollView.backgroundColor = [UIColor grayColor]; [self addSubview:scrollView]; [self.scrollView makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self); }]; [self generateContent]; return self; } - (void)generateContent { UIView* contentView = UIView.new; [self.scrollView addSubview:contentView]; [contentView makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.scrollView); make.width.equalTo(self.scrollView); }]; UIView *lastView; CGFloat height = 25; for (int i = 0; i 8.9.2. 水平方向 static UIEdgeInsets padding; @implementation MASExampleScrollHorView - (id)init { self = [super init]; if (!self) return nil; padding = UIEdgeInsetsMake(10, 10, 10, 10); UIScrollView *scrollView = [LayoutUtils creatUIScrollView]; [self addSubview:scrollView]; [scrollView makeConstraints:^(MASConstraintMaker *make) { make.edges.mas_equalTo(padding); // make.edges.equalTo(self).mas_equalTo(padding); }]; // 设置scrollView的子视图，即过渡视图contentSize UIView* contentView = [LayoutUtils createView]; [scrollView addSubview:contentView]; [contentView makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(scrollView); make.height.equalTo(scrollView); }]; // 动态添加子视图到 contentView 上 UIView *lastView = nil; for (int i = 0; i 8.10. Array的Button数组 - (id)init { self = [super init]; if (!self) return nil; [lowerButton mas_makeConstraints:^(MASConstraintMaker *make) { make.left.equalTo(self).with.offset(10.0); }]; [centerButton mas_makeConstraints:^(MASConstraintMaker *make) { make.centerX.equalTo(self); }]; [raiseButton mas_makeConstraints:^(MASConstraintMaker *make) { make.right.equalTo(self).with.offset(-10); }]; self.buttonViews = @[ raiseButton, lowerButton, centerButton ]; return self; } - (void)centerAction { self.offset = 0.0; } - (void)raiseAction { self.offset -= kArrayExampleIncrement; } - (void)lowerAction { self.offset += kArrayExampleIncrement; } - (void)setOffset:(CGFloat)offset { _offset = offset; [self setNeedsUpdateConstraints]; } - (void)updateConstraints { [self.buttonViews updateConstraints:^(MASConstraintMaker *make) { make.baseline.equalTo(self.mas_centerY).with.offset(self.offset); }]; [super updateConstraints]; } 8.11. layoutMargins 8.12. mas_distributeViewsAlongAxis [arr mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedSpacing:20 leadSpacing:5 tailSpacing:5]; [arr makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(@60); make.height.equalTo(@60); }]; [arr mas_distributeViewsAlongAxis:MASAxisTypeVertical withFixedSpacing:20 leadSpacing:5 tailSpacing:5]; [arr makeConstraints:^(MASConstraintMaker *make) { make.left.equalTo(@0); make.width.equalTo(@60); }]; [arr mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedItemLength:30 leadSpacing:200 tailSpacing:30]; [arr makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(@60); make.height.equalTo(@60); }]; [arr mas_distributeViewsAlongAxis:MASAxisTypeVertical withFixedItemLength:30 leadSpacing:30 tailSpacing:200]; [arr makeConstraints:^(MASConstraintMaker *make) { make.left.equalTo(@0); make.width.equalTo(@60); }]; + (BOOL)requiresConstraintBasedLayout { return YES; } - (id)init { self = [super init]; if (!self) return nil; NSLog(@\"%s:%@\",__FUNCTION__,NSStringFromCGRect(self.frame)); UIView *contentView = [LayoutUtils createView]; [self addSubview:contentView]; [contentView makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self).offset(@(20)); make.left.right.equalTo(self); }]; UIView *lastView = nil; NSInteger itemsCount = 11; NSInteger rowCount = 3;// 设置每行有4个Item NSInteger rowNum = (itemsCount/rowCount) + ((NSInteger)(itemsCount%rowCount>0));//显示的总行数 NSInteger itemHeight = 80; for (int j = 0; j *rowArray = [NSMutableArray array]; for (int i = 0; i itemsCount - 1) { label.text = @\"\"; [label setBackgroundColor:UIColor.clearColor]; } } if (rowArray.count > 0) { [rowArray mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedSpacing:15 leadSpacing:10 tailSpacing:10]; [rowArray makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(@((itemHeight+20)*j)); make.height.equalTo(@(itemHeight)); }]; } } if (lastView) { [contentView makeConstraints:^(MASConstraintMaker *make) { make.bottom.mas_equalTo(lastView.mas_bottom); }]; } UIView *bottomView = [LayoutUtils createView]; [self addSubview:bottomView]; [bottomView makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(contentView.mas_bottom).offset(@(20)); make.left.right.equalTo(self); make.height.equalTo(@(40)); }]; return self; } 8.13. 多行label的约束问题? preferredMaxLayoutWidth: 多行label的约束问题。 // 已经确认好了位置 // 在layoutSubviews中确认label的preferredMaxLayoutWidth值 - (void)layoutSubviews { [super layoutSubviews]; // 你必须在 [super layoutSubviews] 调用之后，longLabel的frame有值之后设置preferredMaxLayoutWidth self.longLabel.preferredMaxLayoutWidth = self.frame.size.width-100; // 设置preferredLayoutWidth后，需要重新布局 [super layoutSubviews]; } 8.14. multipler、dividedBy [view makeConstraints:^(MASConstraintMaker *make) { make.center.equalTo(self); make.width.equalTo(view.mas_height).multipliedBy(2); // width = height*2 ==> height = width/2 //make.height.equalTo(view.mas_width).dividedBy(2);// height = width/2 make.width.and.height.equalTo(self).width.priorityLow(); }]; 8.15. UITableView 8.15.1. UITableViewDataSource // ================= MASTableViewDataSorceImpl ==================== @interface MASTableViewDataSorceImpl : NSObject @property (strong, nonatomic) NSArray *dataSource; @end @implementation MASTableViewDataSorceImpl - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{ return self.dataSource.count; } -(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ return [MASTableViewNormalCell cellWithTableView:tableView indexPath:indexPath]; } @end // ================= MASTableViewDataSorceSubImpl ==================== @interface MASTableViewDataSorceSubImpl : MASTableViewDataSorceImpl @end @implementation MASTableViewDataSorceSubImpl -(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ MASTableViewNormalCell *cell = [MASTableViewNormalCell cellWithTableView:tableView indexPath:indexPath]; cell.titleLabel.text = self.dataSource[indexPath.row]; return cell; } @end 8.15.2. MASTableViewNormalCell // ================= .h ==================== @interface MASTableViewNormalCell : UITableViewCell @property (strong, nonatomic) NSIndexPath *indexPath; @property (strong, nonatomic) UILabel *titleLabel; +(NSString*)reuseIdentifier; +(MASTableViewNormalCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath; @end // ================= .m ==================== static UIEdgeInsets const kPadding = {10, 10, 10, 10}; @implementation MASTableViewNormalCell #pragma mark - Init Views +(NSString*)reuseIdentifier{ return NSStringFromClass([self class]); } +(MASTableViewNormalCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath{ MASTableViewNormalCell *cell = [tableView dequeueReusableCellWithIdentifier:[self reuseIdentifier]]; if (!cell) { cell = [[MASTableViewNormalCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:[self reuseIdentifier]]; } return cell; } -(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{ if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) { self.selectionStyle =UITableViewCellSelectionStyleNone; [self.contentView addSubview:self.titleLabel]; [self.titleLabel makeConstraints:^(MASConstraintMaker *make) { make.left.top.right.bottom.equalTo(self.contentView).insets(kPadding); // 关键代码 }]; } return self; } -(UILabel *)titleLabel{ if (!_titleLabel) { _titleLabel = [[UILabel alloc] init]; [_titleLabel setLineBreakMode:NSLineBreakByWordWrapping]; [_titleLabel setTextAlignment:NSTextAlignmentLeft]; [_titleLabel setNumberOfLines:0]; [_titleLabel setTextColor:UIColor.blackColor]; } return _titleLabel; } #pragma mark setter @end 8.15.3. UITableView @interface MASExampleTableView() @property (strong, nonatomic) UITableView *tableView; @property (strong, nonatomic) MASTableViewDataSorceSubImpl *dataSource; @property (strong, nonatomic) NSArray *data; @end @implementation MASExampleTableView - (instancetype)init { if (self == [super init]) { self.dataSource = [MASTableViewDataSorceSubImpl new]; self.dataSource.dataSource = self.data; [self addSubview:self.tableView]; self.tableView.dataSource = self.dataSource; self.tableView.delegate = self.delegate; [self.tableView reloadData]; [self.tableView makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self); }]; } return self; } -(UITableView *)tableView{ if (!_tableView) { _tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain]; _tableView.estimatedRowHeight = 44; _tableView.rowHeight = UITableViewAutomaticDimension;//默认值可省略。 } return _tableView; } @end 8.16. 外部的部分靠内部支撑 UIView *superView = [LayoutUtils createView]; UIButton *tapButton = [LayoutUtils createButtonWithTitle:@\"Add\" selector:@selector(add)]; UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10); [superView addSubview:tapButton]; [superView makeConstraints:^(MASConstraintMaker *make) { make.left.right.top.mas_equalTo(padding); // 父控件只适配了left.right.top的边距，bottom的的距离根据其内子控件的 bottom }]; [tapButton makeConstraints:^(MASConstraintMaker *make) { make.left.right.top.mas_equalTo(padding); make.bottom.mas_equalTo(padding);// make.height.equalTo(@(100)); }]; 8.17. UIButton自适应宽度 - (id)init { self = [super init]; if (!self) return nil; UIButton *button = [LayoutUtils createButtonWithTitle:@\"UIButton宽度\" target:self selector:@selector(clickButton:)]; [self addSubview:button]; [button mas_makeConstraints:^(MASConstraintMaker *make) { make.center.mas_equalTo(self); //make.height.mas_equalTo(@[button.titleLabel.mas_height,button.imageView.mas_height]); make.height.mas_equalTo(@[button.titleLabel.mas_height]); make.width.mas_lessThanOrEqualTo(300); }]; return self; } -(void)clickButton:(UIButton*)sender{ [sender setTitle:[sender.currentTitle stringByAppendingString:@\"自适应\"] forState:UIControlStateNormal]; } 8.18. UITableView九宫格 @implementation MASTableViewImagesCell -(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{ if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) { self.selectionStyle = UITableViewCellSelectionStyleNone; _imagesArr = [NSArray array]; self.picContentView = [LayoutUtils createView]; [self.contentView addSubview:self.picContentView]; [self.picContentView makeConstraints:^(MASConstraintMaker *make) { make.left.top.right.equalTo(self.contentView); }]; self.bottomView = [LayoutUtils createView]; [self.contentView addSubview:self.bottomView]; [self.bottomView makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.picContentView.mas_bottom).insets(kPadding); make.height.equalTo(@100); make.left.bottom.right.equalTo(kPadding); }]; } return self; } -(void)updateData{ NSLog(@\"%s\",__func__); if (self.cellData.imgs && self.cellData.imgs.length > 0) { NSString *temptString = self.cellData.imgs; if ([[temptString substringFromIndex:temptString.length-1] isEqualToString:@\",\"]) { temptString = [temptString substringToIndex:[temptString length]-1]; } self.imagesArr = [temptString componentsSeparatedByString:@\",\"]; [self createPicView:self.imagesArr.count]; } } - (void)createPicView:(NSInteger)itemNum { if (itemNum 0)); UIView *lastView = nil; for (int i = 0; i num-1) { view.backgroundColor = [UIColor clearColor]; view.layer.borderColor = [UIColor clearColor].CGColor; } [self.picContentView addSubview:view]; [masonryViewArray addObject:view]; lastView = view; } // 固定 item 之间的间距，item 的宽或者高自动缩放 [masonryViewArray mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedSpacing:15 leadSpacing:kPadding.left tailSpacing:kPadding.right]; // 设置array的垂直方向的约束 [masonryViewArray makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(@((100 * i) + kPadding.top)); make.height.equalTo(@80).priorityLow(); }]; } [self.picContentView makeConstraints:^(MASConstraintMaker *make) { make.bottom.equalTo(lastView.mas_bottom).priorityLow(); }]; } @end 8.19. UITableView 折叠、展开 @interface MASTableViewProfieCell() @property (strong, nonatomic) MASConstraint* masHeight; @end @implementation MASTableViewProfieCell -(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{ if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) { self.selectionStyle = UITableViewCellSelectionStyleNone; self.headImageView = [LayoutUtils createView]; self.headImageView.layer.cornerRadius = 30; self.headImageView.layer.masksToBounds = YES; [self.contentView addSubview:self.headImageView]; [self.headImageView makeConstraints:^(MASConstraintMaker *make) { make.width.equalTo(@60); make.height.equalTo(@60).priorityLow(); make.left.top.equalTo(kPadding); }]; [self.headImageView setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical]; self.titleLabel = [LayoutUtils fixedLabelWithText:@\"\"]; [self.contentView addSubview:self.titleLabel]; self.titleLabel.numberOfLines = 1; [self.titleLabel makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(kPadding); make.left.equalTo(self.headImageView.mas_right).insets(kPadding); make.right.lessThanOrEqualTo(kPadding); }]; self.descabel = [LayoutUtils fixedLabelWithText:@\"\"]; self.descabel.textAlignment = NSTextAlignmentLeft; [self.contentView addSubview:self.descabel]; [self.descabel makeConstraints:^(MASConstraintMaker *make) { make.left.equalTo(self.headImageView.mas_right).insets(kPadding); make.top.equalTo(self.headImageView.mas_centerY); make.right.lessThanOrEqualTo(kPadding); make.bottom.equalTo(kPadding); make.bottom.greaterThanOrEqualTo(self.headImageView); //self.masHeight = make.height.lessThanOrEqualTo(@100); }]; } return self; } -(void)updateData{ self.titleLabel.text = self.cellData.content; self.descabel.text = self.cellData.content; if (self.cellData.isExpended) { NSLog(@\"==1==\"); //[self.masHeight uninstall]; self.descabel.numberOfLines = 0; }else{ NSLog(@\"==2==\"); //[self.masHeight install]; self.descabel.numberOfLines = 3; } [super updateData]; } @end 另外一种布局约束，既可以解决headImageView.bottom cell的底部必须超过heaImageView，同时如果descLabel.bottom cell的底部必须超过descLabel；也支持折叠、展开。 @interface MASTableViewProfieCell() @property (strong, nonatomic) MASConstraint* masHeight; @end @implementation MASTableViewProfieCell -(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{ if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) { self.selectionStyle = UITableViewCellSelectionStyleNone; self.headImageView = [LayoutUtils createView]; self.headImageView.layer.cornerRadius = 30; self.headImageView.layer.masksToBounds = YES; [self.contentView addSubview:self.headImageView]; [self.headImageView makeConstraints:^(MASConstraintMaker *make) { make.width.equalTo(@60); make.height.equalTo(@60).priorityLow(); make.left.top.equalTo(kPadding); make.bottom.lessThanOrEqualTo(kPadding); //关键代码 }]; [self.headImageView setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical]; self.titleLabel = [LayoutUtils fixedLabelWithText:@\"\"]; [self.contentView addSubview:self.titleLabel]; self.titleLabel.numberOfLines = 1; [self.titleLabel makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(kPadding); make.left.equalTo(self.headImageView.mas_right).insets(kPadding); make.right.lessThanOrEqualTo(kPadding); }]; self.descabel = [LayoutUtils fixedLabelWithText:@\"\"]; self.descabel.textAlignment = NSTextAlignmentLeft; [self.contentView addSubview:self.descabel]; [self.descabel makeConstraints:^(MASConstraintMaker *make) { make.left.equalTo(self.headImageView.mas_right).insets(kPadding); make.top.equalTo(self.headImageView.mas_centerY); make.right.lessThanOrEqualTo(kPadding); //make.bottom.equalTo(kPadding); self.masHeight = make.height.lessThanOrEqualTo(@100); //关键代码 //make.bottom.greaterThanOrEqualTo(self.headImageView); make.bottom.lessThanOrEqualTo(kPadding); //关键代码 }]; } return self; } -(void)updateData{ self.titleLabel.text = self.cellData.content; self.descabel.text = self.cellData.content; if (self.cellData.isExpended) { NSLog(@\"==1==\"); [self.masHeight uninstall]; //关键代码 self.descabel.numberOfLines = 0; }else{ NSLog(@\"==2==\"); [self.masHeight install]; //关键代码 self.descabel.numberOfLines = 3; } [super updateData]; } -(void)updateConstraints{ [super updateConstraints]; } @end 9. 资料 系统理解 iOS 自动布局 "},"Github/Reactivecocoa.html":{"url":"Github/Reactivecocoa.html","title":"Reactivecocoa","keywords":"","body":"1. 基础1.1. RACSignal 触发流程1.2. RACSubject、RACReplaySubject2. 冷信号与热信号2.1. 热信号2.2. 冷信号2.3. 冷信号、热信号比较3. 基础使用3.1. RACMulticastConnection3.2. 线程操作3.3. 信号节流:throttle3.4. 信号错误重试:retry3.5. 获取信号中的信号: switchToLatest3.6. 信号发送顺序:doNext、doCompleted3.7. 信号取值:take、takeUntil、takeLast3.8. map、flattenMap(拦截信号处理数据)3.8.1. 示例3.8.2. 示例3.9. 信号操作时间:delay(延迟)3.10. 信号操作时间:interval(定时)3.11. 信号操作时间:timeout(超时)3.12. 信号过滤:distinctUntilChanged3.13. 信号过滤:ignore(忽略)3.14. 信号过滤:filter(过滤)3.15. 信号合并:combineLatest(结合)、reduce(聚合)3.16. 信号合并:zipWith(压缩)3.17. 信号合并:merge(合并)3.18. 信号拼接:then(连接)3.19. 信号拼接:concat(合并)3.20. RACObserve3.21. 其他使用4. RACCommand4.1. 使用5. RACChannel5.1. RACChannel实现双向绑定6. Foundation6.1. NSObject6.1.1. NSObject+RACLifting6.2. NSNotificationCenter6.3. NSString7. UIKit7.1. UIControl+RACSignalSupportPrivate7.2. UITextField+RACSignalSupport8. 信号相关类9. Disposable10. Tips11. RAC&MVVM开发规约11.1. VM层11.2. V层11.2.1. Controller11.2.2. 自定义UIView11.2.3. 自定义复用机制UIView12. MVVM&RAC12.1. 使用设计12.2. 示例：列表刷新12.2.1. CircleListViewController12.2.2. ViewModel12.2.3. View12.3. TableView&UIButton12.4. TableView&UITextField12.4.1. TableViewCell&UITextField12.5. 示例：登录12.6. 示例：豆瓣列表12.7. RACCommand中的sendError没反应的解答12.8. 示例:多接口请求12.9. 示例：RAC、distinctUntilChanged12.10. 示例：发邮件12.11. 示例：验证码倒计时13. 资料代码的仓库 1. 基础 1.1. RACSignal 触发流程 下面代码是RACSignal创建和被订阅的演示。 -(void)test_sig_1{ //Create a Signal. RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { for (NSInteger i = 0; i RACSignal底层实现: 创建信号，首先把didSubscribe保存到信号中，还不会触发。 当信号被订阅(调用signal的subscribeNext:nextBlock)时： subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中 subscribeNext内部会调用siganl的didSubscribe 当信号订阅完成, 不在发送数据的时候, 最好调用完成发送的[subscriber sendCompleted] 订阅完成的时候, 内部会自动调用[RACDisposable disposable]取消订阅信号 当siganl的didSubscribe中调用[subscriber sendNext:@1]时，sendNext底层其实就是执行subscriber的nextBlock RACSignal的一些子类及作用： // `RACDynamicSignal`(动态信号) 是`RACSignal`的子类,使用一个`block`来实现订阅行为。 @interface RACDynamicSignal : RACSignal // block 中 id subscriber + (RACSignal *)createSignal:(RACDisposable * (^)(id subscriber))didSubscribe; @end // 一元信号，用来实现 RACSignal 的 +return:方法 @interface RACReturnSignal : RACSignal + (RACSignal *)return:(ValueType)value; @end // 错误信号，用来实现 RACSignal 的 +error: 方法 @interface RACErrorSignal : RACSignal + (RACSignal *)error:(NSError *)error; @end // 通道终端，代表 RACChannel 的一个终端，用来实现双向绑定 @interface RACChannelTerminal : RACSignal - (instancetype)init __attribute__((unavailable(\"Instantiate a RACChannel instead\"))); - (void)sendNext:(nullable ValueType)value; @end // 信号提供者，自己可以充当信号，又能发送信号 @interface RACSubject : RACSignal + (instancetype)subject; - (void)sendNext:(nullable ValueType)value; @end RACSubscriber 订阅者协议的内容： @protocol RACSubscriber - (void)sendNext:(nullable id)value; - (void)sendError:(nullable NSError *)error; - (void)sendCompleted; - (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable; @end 1.2. RACSubject、RACReplaySubject RACSubject 信号提供者： RACSubject(信号提供者)，自己可以充当信号，又能发送信号。 触发条件：先订阅, 再发送信号。 使用场景:通常用来代替代理/通知。 RACReplaySubject 重复提供信号： 先发送信号，再订阅信号 @interface TestViewModel : NSObject @property (strong, nonatomic) RACSignal *signal; @property (strong, nonatomic) RACReplaySubject *replaySubject; @property (strong, nonatomic) RACSubject *subject; @end @implementation TestViewModel -(RACReplaySubject *)replaySubject{ if (!_replaySubject) { _replaySubject = [RACReplaySubject subject]; } return _replaySubject; } -(RACSubject *)subject{ if (!_subject) { _subject = [RACSubject subject]; } return _subject; } @end @interface TestViewController () @property (weak, nonatomic) IBOutlet UIButton *registerButton; @property (weak, nonatomic) IBOutlet UIButton *loginButton; @property (weak, nonatomic) IBOutlet UILabel *textLabel; @property (weak, nonatomic) IBOutlet UITextField *textField; @property (weak, nonatomic) IBOutlet UIButton *sendSingnalButton; @property (strong, nonatomic) TestViewModel *viewModel; @end @implementation TestViewController - (void)viewDidLoad { [super viewDidLoad]; [[self.loginButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) { NSLog(@\"you clicked the login button!\"); [self.viewModel.replaySubject subscribeNext:^(id _Nullable x) { NSLog(@\"RACReplaySubject %@\",x); }]; [self.viewModel.subject subscribeNext:^(id _Nullable x) { NSLog(@\"RACSubject %@\",x); }]; }]; [[self.registerButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) { NSLog(@\"you clicked the register button!\"); [self.viewModel.replaySubject subscribeNext:^(id _Nullable x) { NSLog(@\"RACReplaySubject %@\",x); }]; [self.viewModel.subject subscribeNext:^(id _Nullable x) { NSLog(@\"RACSubject %@\",x); }]; }]; [[self.sendSingnalButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) { [self.viewModel.subject sendNext:@2]; [self.viewModel.replaySubject sendNext:@2]; }]; } -(TestViewModel *)viewModel{ if (!_viewModel) { _viewModel = [TestViewModel new]; [_viewModel.replaySubject sendNext:@1]; [_viewModel.subject sendNext:@1]; } return _viewModel; } @end /* you clicked the login button! RACReplaySubject 1 ==> RACReplaySubject 先发送了信号，然后再点击login方法进行订阅。这里没有 RACSubject 的打印信息，是因为 RACSubject 必须先订阅再发送信号。 you clicked the register button! RACReplaySubject 1 ==> RACReplaySubject 先发送了信号，然后再点击login方法进行订阅。这里没有 RACSubject 的打印信息，是因为 RACSubject 必须先订阅再发送信号。 RACSubject 2 RACSubject 2 ==> login register 两个方法各订阅了一次信号，点击几次方法就会重复订阅 RACReplaySubject 2 ==> login register 两个方法各订阅了一次信号，点击几次方法就会重复订阅 RACReplaySubject 2 RACSubject 2 RACSubject 2 RACReplaySubject 2 RACReplaySubject 2 */ 做一个RACSubject作为代理的简单示例： @interface TestViewModel : NSObject @property (strong, nonatomic) RACSubject *subject; -(void)loadData; @end @implementation TestViewModel -(void)loadData{ // request service data,return data to vc [self.subject sendNext:@1]; } -(RACSubject *)subject{ if (!_subject) { _subject = [RACSubject subject]; } return _subject; } @end @interface TestViewController () @property (weak, nonatomic) IBOutlet UIButton *registerButton; @property (weak, nonatomic) IBOutlet UIButton *loginButton; @property (weak, nonatomic) IBOutlet UILabel *textLabel; @property (weak, nonatomic) IBOutlet UITextField *textField; @property (weak, nonatomic) IBOutlet UIButton *sendSingnalButton; @property (strong, nonatomic) TestViewModel *viewModel; @end @implementation TestViewController - (void)viewDidLoad { [super viewDidLoad]; [self.viewModel.subject subscribeNext:^(id _Nullable x) { NSLog(@\"Service data: %@\",x); }]; @weakify(self) [[self.loginButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) { @strongify(self) NSLog(@\"you clicked the login button!\"); [self.viewModel loadData]; }]; } -(TestViewModel *)viewModel{ if (!_viewModel) { _viewModel = [TestViewModel new]; } return _viewModel; } @end 2. 冷信号与热信号 2.1. 热信号 热信号是主动的，即使你没有订阅事件，它仍然会时刻推送。 例中：信号在 19:37:55 被创建，在 19:37:56 发出信号1，但是没有订阅，在 19:37:57发出信号2，这是有一个订阅。 热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息。 例中：订阅者1和订阅者2都在 19:37:58 收到了数据。 - (void)viewDidLoad { [super viewDidLoad]; RACMulticastConnection * connection = [[RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{ [subscriber sendNext:@1]; }]; [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{ [subscriber sendNext:@2]; }]; [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{ [subscriber sendNext:@3]; }]; [[RACScheduler mainThreadScheduler] afterDelay:4 schedule:^{ [subscriber sendCompleted]; }]; return nil; }]publish]; [connection connect]; RACSignal *signal = connection.signal; NSLog(@\"Signal was created.\"); [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{ [signal subscribeNext:^(id _Nullable x) { NSLog(@\"Subscriber 1 recveive: %@\", x); }]; }]; [[RACScheduler mainThreadScheduler] afterDelay:2.1 schedule:^{ [signal subscribeNext:^(id x) { NSLog(@\"Subscriber 2 recveive: %@\", x); }]; }]; } /* 2020-05-28 19:37:55.689906+0800 RACExample[56065:11840136] Signal was created. 2020-05-28 19:37:57.690140+0800 RACExample[56065:11840136] Subscriber 1 recveive: 2 2020-05-28 19:37:58.690022+0800 RACExample[56065:11840136] Subscriber 1 recveive: 3 2020-05-28 19:37:58.690210+0800 RACExample[56065:11840136] Subscriber 2 recveive: 3 */ 2.2. 冷信号 冷信号是被动的，只有当你订阅的时候，它才会发送消息。 冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。 例中：两个订阅者没有联系，都是基于各自的订阅时间开始接收消息的。 - (void)viewDidLoad { [super viewDidLoad]; RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{ [subscriber sendNext:@1]; }]; [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{ [subscriber sendNext:@2]; }]; [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{ [subscriber sendNext:@3]; }]; [[RACScheduler mainThreadScheduler] afterDelay:4 schedule:^{ [subscriber sendCompleted]; }]; return nil; }]; NSLog(@\"Signal was created.\"); [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{ [signal subscribeNext:^(id _Nullable x) { NSLog(@\"Subscriber 1 recveive: %@\", x); }]; }]; [[RACScheduler mainThreadScheduler] afterDelay:2.1 schedule:^{ [signal subscribeNext:^(id x) { NSLog(@\"Subscriber 2 recveive: %@\", x); }]; }]; } /* 2020-05-28 19:42:38.439542+0800 RACExample[56245:11843585] Signal was created. 2020-05-28 19:42:40.540420+0800 RACExample[56245:11843585] Subscriber 1 recveive: 1 2020-05-28 19:42:41.537044+0800 RACExample[56245:11843585] Subscriber 1 recveive: 2 2020-05-28 19:42:41.849789+0800 RACExample[56245:11843585] Subscriber 2 recveive: 1 2020-05-28 19:42:42.669102+0800 RACExample[56245:11843585] Subscriber 1 recveive: 3 2020-05-28 19:42:42.884800+0800 RACExample[56245:11843585] Subscriber 2 recveive: 2 2020-05-28 19:42:43.841321+0800 RACExample[56245:11843585] Subscriber 2 recveive: 3 */ 2.3. 冷信号、热信号比较 // 冷信号代码 -(void)test_Signal{ // Create an RACReplaySubject signals RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { // Send Signals [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{ [subscriber sendNext:@\"replaySubject send package 1\"]; }]; // Send Signals [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{ [subscriber sendNext:@\"replaySubject send package 2\"]; }]; return [RACDisposable disposableWithBlock:^{ NSLog(@\"disposable\"); }]; }]; NSLog(@\"create Signal\"); // Subscribe the signal [[RACScheduler mainThreadScheduler] afterDelay:0.1 schedule:^{ //Subscriber1 [signal subscribeNext:^(id _Nullable x) { NSLog(@\"Subscriber 1 get a next value: %@ from replay subject\", x); }]; //Subscriber2 [signal subscribeNext:^(id _Nullable x) { NSLog(@\"Subscriber 2 get a next value: %@ from replay subject\", x); }]; }]; // Subscribe the signal [[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{ //Subscriber3 [signal subscribeNext:^(id _Nullable x) { NSLog(@\"Subscriber 3 get a next value: %@ from replay subject\", x); }]; //Subscriber4 [signal subscribeNext:^(id _Nullable x) { NSLog(@\"Subscriber 4 get a next value: %@ from replay subject\", x); }]; }]; } // Subject 热信号代码 -(void)test_RACSubject{ // Create a RACSubject signal RACSubject *subject = [RACSubject subject]; NSLog(@\"create Signal\"); // Subscribe the signal [[RACScheduler mainThreadScheduler] afterDelay:0.1 schedule:^{ //Subscriber1 [subject subscribeNext:^(id _Nullable x) { NSLog(@\"Subscriber 1 get a next value: %@ from subject\", x); }]; //Subscriber2 [subject subscribeNext:^(id _Nullable x) { NSLog(@\"Subscriber 2 get a next value: %@ from subject\", x); }]; }]; // Send Signals [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{ [subject sendNext:@\"subject send package 1\"]; }]; // Subscribe the signal [[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{ //Subscriber3 [subject subscribeNext:^(id _Nullable x) { NSLog(@\"Subscriber 3 get a next value: %@ from subject\", x); }]; //Subscriber4 [subject subscribeNext:^(id _Nullable x) { NSLog(@\"Subscriber 4 get a next value: %@ from subject\", x); }]; }]; // Send Signals [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{ [subject sendNext:@\"subject send package 2\"]; }]; } // ReplaySubject 热信号代码 -(void)test_RACReplaySubject{ // Create an RACReplaySubject signals RACSubject *replaySubject = [RACReplaySubject subject]; NSLog(@\"create Signal\"); // Subscribe the signal [[RACScheduler mainThreadScheduler] afterDelay:0.1 schedule:^{ //Subscriber1 [replaySubject subscribeNext:^(id _Nullable x) { NSLog(@\"Subscriber 1 get a next value: %@ from replay subject\", x); }]; //Subscriber2 [replaySubject subscribeNext:^(id _Nullable x) { NSLog(@\"Subscriber 2 get a next value: %@ from replay subject\", x); }]; }]; // Send Signals [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{ [replaySubject sendNext:@\"replaySubject send package 1\"]; }]; // Subscribe the signal [[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{ //Subscriber3 [replaySubject subscribeNext:^(id _Nullable x) { NSLog(@\"Subscriber 3 get a next value: %@ from replay subject\", x); }]; //Subscriber4 [replaySubject subscribeNext:^(id _Nullable x) { NSLog(@\"Subscriber 4 get a next value: %@ from replay subject\", x); }]; }]; // Send Signals [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{ [replaySubject sendNext:@\"replaySubject send package 2\"]; }]; } RACSignal和热信号RACSubject时间比较： RACSubject中，4个订阅者共享subject,在subject发送信号的时候，所有的订阅者都能收到信号数据；因为subscriber3、subscriber4订阅的时间稍后，错过了subject发送的信号数据。 对比发现: subject类似直播，错过了就不再处理。而signal类似点播，每次订阅都会从头开始。所以我们有理由认定subject天然就是热信号。 冷信号RACSignal和热信号ReplayRACSubject时间比较： 热信号RACSubject和热信号ReplayRACSubject时间比较： ReplayRACSubject中，Subscriber 3与Subscriber 4在订阅后马上接收到了“历史值”。对于Subscriber 3和Subscriber 4来说，它们只关心“历史的值”而不关心“历史的时间线”。· 热信号和冷信号类： 3. 基础使用 3.1. RACMulticastConnection RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NSLog(@\"发送信号1\"); [subscriber sendNext:@\"1\"]; return nil; }]; [signal subscribeNext:^(id _Nullable x) { NSLog(@\"第一次订阅：%@\",x);}]; [signal subscribeNext:^(id _Nullable x) { NSLog(@\"第二次订阅：%@\",x);}]; /* 2020-06-08 16:20:16.479977+0800 RACExample[46980:352112] 发送信号1 2020-06-08 16:20:16.480517+0800 RACExample[46980:352112] 第一次订阅：1 2020-06-08 16:20:16.480976+0800 RACExample[46980:352112] 发送信号1 2020-06-08 16:20:16.481336+0800 RACExample[46980:352112] 第二次订阅：1 */ 在信号signal被订阅2次以后，createSignal:block也被触发了2次。通过RACMulticastConnection可以解决信号被n次订阅后，block也会被触发n次的情况。 RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NSLog(@\"发送信号1\"); [subscriber sendNext:@\"1\"]; return nil; }]; RACMulticastConnection *signalBconnect = [signal publish]; [signalBconnect.signal subscribeNext:^(id _Nullable x) { NSLog(@\"第一次订阅：%@\",x);}]; [signalBconnect.signal subscribeNext:^(id _Nullable x) { NSLog(@\"第二次订阅：%@\",x);}]; [signalBconnect connect]; /* 2020-06-08 16:25:18.009553+0800 RACExample[47186:354797] 发送信号1 2020-06-08 16:25:18.009805+0800 RACExample[47186:354797] 第一次订阅：1 2020-06-08 16:25:18.009907+0800 RACExample[47186:354797] 第二次订阅：1 */ 也可以通过RACSignal热信号去解决，其实RACMulticastConnection就相当于把signal变成了热信号： RACSubject *subject = [RACSubject subject]; [subject subscribeNext:^(id _Nullable x) { NSLog(@\"第一次订阅：%@\",x);}]; [subject subscribeNext:^(id _Nullable x) { NSLog(@\"第二次订阅：%@\",x);}]; NSLog(@\"发送信号1\"); [subject sendNext:@\"1\"]; /* 2020-06-08 16:26:34.201680+0800 RACExample[47240:355739] 发送信号1 2020-06-08 16:26:34.202059+0800 RACExample[47240:355739] 第一次订阅：1 2020-06-08 16:26:34.202349+0800 RACExample[47240:355739] 第二次订阅：1 */ 3.2. 线程操作 副作用：关于信号与线程,我们把在创建信号时block中的代码称之为副作用。 deliverON：切换到指定线程中，可用于回到主线中刷新UI,内容传递切换到指定线程中， subscribeOn：内容传递和副作用都会切换到指定线程中。 deliverOnMainThread：能保证原信号subscribeNext，sendError，sendCompleted都在主线程MainThread中执行。 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ [[RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NSLog(@\"sendNext1:%@\",[NSThread currentThread]);// sendNext1:{number = 4, name = (null)} [subscriber sendNext:@\"1\"]; return nil; }] subscribeNext:^(id _Nullable x) { NSLog(@\"subscribeNext%@:%@\",x,[NSThread currentThread]);//subscribeNext1:{number = 4, name = (null)} }]; }); // 发送消息、接收消息都是在异步线程。 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ [[[RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NSLog(@\"sendNext1:%@\",[NSThread currentThread]);// sendNext1:{number = 4, name = (null)} [subscriber sendNext:@\"1\"]; return nil; }] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(id _Nullable x) { NSLog(@\"subscribeNext%@:%@\",x,[NSThread currentThread]);//subscribeNext1:{number = 1, name = main} }]; }); // 接收消息在主线程。 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ [[[RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NSLog(@\"sendNext1:%@\",[NSThread currentThread]);// sendNext1:{number = 1, name = main} [subscriber sendNext:@\"1\"]; return nil; }] subscribeOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(id _Nullable x) { NSLog(@\"subscribeNext%@:%@\",x,[NSThread currentThread]);//subscribeNext1:{number = 1, name = main} }]; }); // 发送消息、接收消息都是在主线程。 3.3. 信号节流:throttle throttle节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。 [[[RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NSLog(@\"11\");[subscriber sendNext:@\"发送消息11\"]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@\"21\");[subscriber sendNext:@\"发送消息21\"]; NSLog(@\"22\");[subscriber sendNext:@\"发送消息22\"]; }); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@\"31\");[subscriber sendNext:@\"发送消息31\"]; NSLog(@\"32\");[subscriber sendNext:@\"发送消息32\"]; NSLog(@\"33\");[subscriber sendNext:@\"发送消息33\"]; }); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(4 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@\"41\");[subscriber sendNext:@\"发送消息41\"]; NSLog(@\"42\");[subscriber sendNext:@\"发送消息42\"]; NSLog(@\"43\");[subscriber sendNext:@\"发送消息43\"]; NSLog(@\"44\");[subscriber sendNext:@\"发送消息44\"]; }); return nil; }] throttle:2] subscribeNext:^(id _Nullable x) { NSLog(@\"Next:%@\",x); }]; /* 2020-06-08 19:09:37.356497+0800 RACExample[54681:455884] 11 2020-06-08 19:09:39.357101+0800 RACExample[54681:455884] Next:发送消息11 2020-06-08 19:09:39.357366+0800 RACExample[54681:455884] 21 2020-06-08 19:09:39.357518+0800 RACExample[54681:455884] 22 2020-06-08 19:09:40.540307+0800 RACExample[54681:455884] 31 2020-06-08 19:09:40.541107+0800 RACExample[54681:455884] 32 2020-06-08 19:09:40.541341+0800 RACExample[54681:455884] 33 2020-06-08 19:09:41.357386+0800 RACExample[54681:455884] 41 2020-06-08 19:09:41.357600+0800 RACExample[54681:455884] 42 2020-06-08 19:09:41.357734+0800 RACExample[54681:455884] 43 2020-06-08 19:09:41.357856+0800 RACExample[54681:455884] 44 2020-06-08 19:09:43.369260+0800 RACExample[54681:455884] Next:发送消息44 */ 3.4. 信号错误重试:retry retry重试 ：只要失败，就会重新执行创建信号中的block,直到成功. static int signalANum = 0; RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { if (signalANum >= 5) { NSLog(@\"sendNext %d\",signalANum); [subscriber sendNext:[NSString stringWithFormat:@\"尝试次数累计：%d\",signalANum]]; [subscriber sendCompleted]; }else{ NSLog(@\"sendError %d\",signalANum); [subscriber sendError:[NSError errorWithDomain:@\"\" code:0 userInfo:@{NSLocalizedDescriptionKey:@\"Something is wrong!\"}]]; } signalANum++; return nil; }]; [[signal retry] subscribeNext:^(id _Nullable x) { NSLog(@\"subscribeNext：%@\",x); } error:^(NSError * _Nullable error) { NSLog(@\"error info: %@\",error.localizedDescription); }]; /* 2020-06-08 19:03:16.750255+0800 RACExample[54389:451981] sendError 0 2020-06-08 19:03:16.774608+0800 RACExample[54389:451981] sendError 1 2020-06-08 19:03:16.774899+0800 RACExample[54389:451981] sendError 2 2020-06-08 19:03:16.775074+0800 RACExample[54389:451981] sendError 3 2020-06-08 19:03:16.775254+0800 RACExample[54389:451981] sendError 4 2020-06-08 19:03:16.775446+0800 RACExample[54389:451981] sendNext 5 2020-06-08 19:03:16.775579+0800 RACExample[54389:451981] subscribeNext：尝试次数累计：5 */ 3.5. 获取信号中的信号: switchToLatest switchToLatest只能用于信号中的信号(否则崩溃)，获取最新发送的信号。 switchToLatest:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。 3.6. 信号发送顺序:doNext、doCompleted 发送信号前与发送信号后操作：doNext、doCompleted。 doNext：在订阅者发送消息sendNext之前执行。 doCompleted：在订阅者发送完成sendCompleted之后执行。 RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NSLog(@\"发送信号：1\"); [subscriber sendNext:@\"发送信号：1\"]; [subscriber sendCompleted]; return nil; }]; [[[signal doNext:^(id _Nullable x) { NSLog(@\"doNext,%@\",x); }] doCompleted:^{ NSLog(@\"doCompleted\"); }] subscribeNext:^(id _Nullable x) { NSLog(@\"激活信号：%@\",x); }]; /* 2020-06-08 18:49:53.413848+0800 RACExample[53730:443023] 发送信号：1 2020-06-08 18:49:53.414098+0800 RACExample[53730:443023] doNext,发送信号：1 2020-06-08 18:49:53.414220+0800 RACExample[53730:443023] 激活信号：发送信号：1 2020-06-08 18:49:53.414823+0800 RACExample[53730:443023] doCompleted */ 3.7. 信号取值:take、takeUntil、takeLast take:从开始一共取N次的信号 takeLast:取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号. takeUntil:(RACSignal):获取信号直到某个信号执行完成(原始信号一直发送信号，直到，替代的信号发出事件，原始信号终止)。 skip:(NSUInteger):跳过几个信号,不接受。 -(RACSignal*)createSignal{ return [RACSignal createSignal:^RACDisposable *(id subscriber) { for (int i = 0; i 上面是正常的订阅。 -(void)test_take{ [[signal take:2] subscribeNext:^(id _Nullable x) { NSLog(@\"subscribeNext -- %@\", x); }]; /* 2020-06-03 14:53:40.530949+0800 RACExample[30990:2262219] subscriber sendNext -- 0 2020-06-03 14:53:40.531286+0800 RACExample[30990:2262219] subscribeNext -- 0 2020-06-03 14:53:40.531476+0800 RACExample[30990:2262219] subscriber sendNext -- 1 2020-06-03 14:53:40.531610+0800 RACExample[30990:2262219] subscribeNext -- 1 2020-06-03 14:53:40.531734+0800 RACExample[30990:2262219] subscriber sendNext -- 2 2020-06-03 14:53:40.531829+0800 RACExample[30990:2262219] subscriber sendNext -- 3 2020-06-03 14:53:40.531924+0800 RACExample[30990:2262219] subscriber sendNext -- 4 2020-06-03 14:53:40.532056+0800 RACExample[30990:2262219] sendCompleted */ } take:2 : 只取前两次订阅的信号。 -(void)test_take{ [[[signal skip:1] take:1] subscribeNext:^(id _Nullable x) { NSLog(@\"subscribeNext -- %@\", x); }]; /* 2020-06-03 14:59:58.615703+0800 RACExample[31246:2265921] subscriber sendNext -- 0 ==> 虽然发送的数据，但是 subscriber 没有使用，跳过这一条 2020-06-03 14:59:58.616069+0800 RACExample[31246:2265921] subscriber sendNext -- 1 2020-06-03 14:59:58.616254+0800 RACExample[31246:2265921] subscribeNext -- 1 ==> take:1 2020-06-03 14:59:58.616376+0800 RACExample[31246:2265921] subscriber sendNext -- 2 2020-06-03 14:59:58.616494+0800 RACExample[31246:2265921] subscriber sendNext -- 3 2020-06-03 14:59:58.616608+0800 RACExample[31246:2265921] subscriber sendNext -- 4 */ } skip:1和take:1 : 跳过第一条开始接收数据，并且只取前一条数据。 -(void)test_takeLast{ [[signal takeLast:1] subscribeNext:^(id _Nullable x) { NSLog(@\"subscribeNext -- %@\", x); }]; /* 2020-06-03 15:04:32.363153+0800 RACExample[31419:2268388] signal -- 0 2020-06-03 15:04:32.363415+0800 RACExample[31419:2268388] signal -- 1 2020-06-03 15:04:32.363534+0800 RACExample[31419:2268388] signal -- 2 2020-06-03 15:04:32.363639+0800 RACExample[31419:2268388] signal -- 3 2020-06-03 15:04:32.363741+0800 RACExample[31419:2268388] signal -- 4 2020-06-03 15:04:32.363943+0800 RACExample[31419:2268388] subscribeNext -- 3 2020-06-03 15:04:32.364053+0800 RACExample[31419:2268388] subscribeNext -- 4 */ } takeLast:1 : 只获取最新的数据。 3.8. map、flattenMap(拦截信号处理数据) map ：将信号内容修改为另一种新值。改变了传递的值。 flattenMap：将源信号映射修改为另一种新的信号(RACSignal),修改了信号本身。 3.8.1. 示例 -(void)test_map{ RACSignal *syncSignal = [RACSignal createSignal:^RACDisposable *(id subscriber) { for (int i = 0; i flattenMap - (void)viewDidLoad { [super viewDidLoad]; RACSignal *syncSignal = [RACSignal createSignal:^RACDisposable *(id subscriber) { for (int i = 0; i name: completed 2020-05-28 14:44:12.520567+0800 RACExample[45556:11658886] signal -- 1 2020-05-28 14:44:12.520658+0800 RACExample[45556:11658886] map -- 1 2020-05-28 14:44:12.520790+0800 RACExample[45556:11658886] subscribeNext -- 1 2020-05-28 14:44:12.520902+0800 RACExample[45556:11658886] name: completed 2020-05-28 14:44:12.521116+0800 RACExample[45556:11658886] signal -- 2 2020-05-28 14:44:12.521573+0800 RACExample[45556:11658886] map -- 2 2020-05-28 14:44:12.521995+0800 RACExample[45556:11658886] subscribeNext -- 2 2020-05-28 14:44:12.522413+0800 RACExample[45556:11658886] name: completed 2020-05-28 14:44:12.522804+0800 RACExample[45556:11658886] signal -- 3 2020-05-28 14:44:12.537218+0800 RACExample[45556:11658886] map -- 3 2020-05-28 14:44:12.537473+0800 RACExample[45556:11658886] subscribeNext -- 3 2020-05-28 14:44:12.537624+0800 RACExample[45556:11658886] name: completed 2020-05-28 14:44:12.537738+0800 RACExample[45556:11658886] signal -- 4 2020-05-28 14:44:12.537825+0800 RACExample[45556:11658886] map -- 4 2020-05-28 14:44:12.537941+0800 RACExample[45556:11658886] subscribeNext -- 4 2020-05-28 14:44:12.538046+0800 RACExample[45556:11658886] name: completed */ 3.8.2. 示例 //创建一个普通信号 RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { for (NSInteger i = 0; i _Nonnull subscriber) { [subscriber sendNext:signal]; [subscriber sendCompleted]; return nil; }]; [signalOfSignals subscribeNext:^(id _Nullable x) { //不使用flattenMap，会打印出内部信号 NSLog(@\"订阅signalOfSignals：%@\",x); }]; [[signalOfSignals flattenMap:^__kindof RACSignal * _Nullable(id _Nullable value) { return [value filter:^BOOL(NSNumber* _Nullable value) { NSLog(@\"filter：%@\",value); return [value integerValue] >= 2 ? YES: NO; }]; }] subscribeNext:^(id _Nullable x) { //使用flattenMap，会打印内部信号的值 NSLog(@\"使用flattenMap后订阅signalOfSignals：%@\",x); }]; /* 2020-06-08 17:54:26.211401+0800 RACExample[51286:408356] 订阅signalOfSignals： name: 2020-06-08 17:54:26.213350+0800 RACExample[51286:408356] filter：0 2020-06-08 17:54:26.213911+0800 RACExample[51286:408356] filter：1 2020-06-08 17:54:26.214308+0800 RACExample[51286:408356] filter：2 2020-06-08 17:54:26.214501+0800 RACExample[51286:408356] 使用flattenMap后订阅signalOfSignals：2 2020-06-08 17:54:26.214642+0800 RACExample[51286:408356] filter：3 2020-06-08 17:54:26.214780+0800 RACExample[51286:408356] 使用flattenMap后订阅signalOfSignals：3 2020-06-08 17:54:26.214903+0800 RACExample[51286:408356] filter：4 2020-06-08 17:54:26.215048+0800 RACExample[51286:408356] 使用flattenMap后订阅signalOfSignals：4 2020-06-08 17:54:26.215221+0800 RACExample[51286:408356] filter：5 2020-06-08 17:54:26.215357+0800 RACExample[51286:408356] 使用flattenMap后订阅signalOfSignals：5 */ 3.9. 信号操作时间:delay(延迟) 延迟发送next。 [[[RACSignal createSignal:^RACDisposable *(id subscriber) { [subscriber sendNext:@(1)]; [subscriber sendCompleted]; return nil; }] delay:2] subscribeNext:^(id _Nullable x) { NSLog(@\"subscribeNext:%@\", x); }]; 3.10. 信号操作时间:interval(定时) 每隔一段时间发出信号 -(void)test_interval_onScheduler{ [[RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(NSDate * _Nullable x) { NSLog(@\"interval -- %@\", x); }]; // 保证上面的延时操作得以完成 [[RACSignal createSignal:^RACDisposable *(id subscriber) { return nil; }] asynchronouslyWaitUntilCompleted:nil]; } /* 2019-08-07 10:10:38.795691+0800 RACDemo02[45596:1122009] interval -- Wed Aug 7 10:10:38 2019 2019-08-07 10:10:39.796486+0800 RACDemo02[45596:1122009] interval -- Wed Aug 7 10:10:39 2019 2019-08-07 10:10:40.796486+0800 RACDemo02[45596:1122009] interval -- Wed Aug 7 10:10:40 2019 2019-08-07 10:10:41.796472+0800 RACDemo02[45596:1122009] interval -- Wed Aug 7 10:10:41 2019 2019-08-07 10:10:42.796452+0800 RACDemo02[45596:1122009] interval -- Wed Aug 7 10:10:42 2019 2019-08-07 10:10:43.796631+0800 RACDemo02[45596:1122009] interval -- Wed Aug 7 10:10:43 2019 2019-08-07 10:10:44.796494+0800 RACDemo02[45596:1122009] interval -- Wed Aug 7 10:10:44 2019 2019-08-07 10:10:45.796493+0800 RACDemo02[45596:1122009] interval -- Wed Aug 7 10:10:45 2019 */ 3.11. 信号操作时间:timeout(超时) timeout：超时，可以让一个信号在一定的时间后，自动报错。 [[[RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{ [subscriber sendNext:@1]; [subscriber sendCompleted]; }]; return nil; }] timeout:2.0 onScheduler:[RACScheduler currentScheduler]] subscribeNext:^(id _Nullable x) { NSLog(@\"subscribeNext：%@\",x); } error:^(NSError * _Nullable error) { NSLog(@\"error：%@\",error.localizedDescription); } completed:^{ NSLog(@\"completed\"); }]; /* error：The operation couldn’t be completed. (RACSignalErrorDomain error 1.) */ 3.12. 信号过滤:distinctUntilChanged distinctUntilChanged:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。 // distinctUntilChanged 只有输入合法才能进行打印 RACSignal *validSearchSignal = [[RACObserve(self, searchText) map:^id _Nullable(NSString* _Nullable value) { return @(value.length > 3); }]distinctUntilChanged]; [validSearchSignal subscribeNext:^(id _Nullable x) { NSLog(@\"search text is valid %@\", x); }]; self.executeSearch = [[RACCommand alloc] initWithEnabled:validSearchSignal signalBlock:^RACSignal * _Nonnull(id _Nullable input) { return [self executeSearchSignal]; }]; 3.13. 信号过滤:ignore(忽略) 忽略完某些值的信号，针对信号值的某一种状态进行忽略，忽略时不会发送消息。 [[self.textField.rac_textSignal ignore:@\"123\"] subscribeNext:^(NSString * _Nullable x) { NSLog(@\"%@\",x); }]; /* 2020-05-28 19:02:21.305235+0800 RACExample[54835:11820168] 1 2020-05-28 19:02:22.011735+0800 RACExample[54835:11820168] 12 2020-05-28 19:02:23.618772+0800 RACExample[54835:11820168] 1234 2020-05-28 19:02:24.323828+0800 RACExample[54835:11820168] 12345 2020-05-28 19:02:25.367480+0800 RACExample[54835:11820168] 123456 2020-05-28 19:02:26.316891+0800 RACExample[54835:11820168] 12345 2020-05-28 19:02:26.874963+0800 RACExample[54835:11820168] 1234 2020-05-28 19:02:29.028761+0800 RACExample[54835:11820168] 12 2020-05-28 19:02:29.442549+0800 RACExample[54835:11820168] 1 2020-05-28 19:02:30.029542+0800 RACExample[54835:11820168] */ 3.14. 信号过滤:filter(过滤) 过滤信号，使用它可以获取满足条件的信号,符合条件的信号才能发出消息。 RAC(self.textLabel,text) = [self.textField.rac_textSignal filter:^BOOL(NSString * _Nullable value) { NSLog(@\"%@\",value); return [value isEqualToString:@\"12345\"]; }]; [[self.textField.rac_textSignal filter:^BOOL(NSString * _Nullable value) { return [value isEqualToString:@\"12345\"]; }] subscribeNext:^(NSString * _Nullable x) { NSLog(@\"%@\",x); }]; 3.15. 信号合并:combineLatest(结合)、reduce(聚合) combineLatest: 将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。combineLatest 功能和 zipWith一样。 reduce:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值,一般都是先结合再聚合。 combineLatest示例: -(void)test_combineLatest_1{ RACReplaySubject * subjectA = [RACReplaySubject subject]; RACReplaySubject * subjectB = [RACReplaySubject subject]; RACReplaySubject * subjectC = [RACReplaySubject subject]; // 三个对象同时发送信号，缺一不可 [subjectA sendNext:@1]; [subjectB sendNext:@2]; [subjectC sendNext:@3]; [[RACSignal combineLatest:@[subjectA,subjectB,subjectC]] subscribeNext:^(id _Nullable x) { // x 的类型为 RACTuple 元组类 -> RACOneTuple、RACTwoTuple、RACThreeTuple、RACFourTuple NSLog(@\"%@\",x); }]; /* 2020-05-28 18:54:23.910080+0800 RACExample[54517:11813771] ( 1, 2, 3 ) */ } combineLatest、reduce示例: - (void)viewDidLoad { [super viewDidLoad]; RACReplaySubject * subjectA = [RACReplaySubject subject]; RACReplaySubject * subjectB = [RACReplaySubject subject]; RACReplaySubject * subjectC = [RACReplaySubject subject]; // 三个对象同时发送信号，缺一不可 [subjectA sendNext:@\"邮件AA\"]; [subjectB sendNext:@\"邮件BB\"]; [subjectC sendNext:@\"邮件CC\"]; // 遵守 NSFastEnumeration 协议的类都可成为数组 // reduce block 参数可以自己根据信号设置 [[RACSignal combineLatest:@[subjectA,subjectB,subjectC] reduce:^id (NSString * signalA,NSString * signalB,NSString * signalC){ // 把这 三个中任意 一个发出的信号值 聚合成一个值 NSString 类型 return [NSString stringWithFormat:@\"A = %@ , B = %@ , C = %@\",signalA , signalB , signalC]; }] subscribeNext:^(id _Nullable x) { NSLog(@\"聚合后三个值变成一个 NSString 类型的值： %@\",x); }]; // 或者 RAC(self.textLabel,text) = [RACSignal combineLatest:@[subjectA,subjectB,subjectC] reduce:^id (NSString * signalA,NSString * signalB,NSString * signalC){ return [NSString stringWithFormat:@\"A = %@ , B = %@ , C = %@\",signalA , signalB , signalC]; }]; } /* 2020-05-28 14:28:01.127620+0800 RACExample[44949:11647817] 聚合后三个值变成一个 NSString 类型的值： A = 邮件AA , B = 邮件BB , C = 邮件CC */ 3.16. 信号合并:zipWith(压缩) 把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。 使用 zipWith 时，两个信号必须同时发出信号内容 -(void)test_zipWith{ RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id subscriber) { [subscriber sendNext:@1]; [subscriber sendCompleted]; return nil; }]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id subscriber) { [subscriber sendNext:@2]; return nil; }]; [[signalA zipWith:signalB] subscribeNext:^(id _Nullable x) { // x 的类型为 RACTuple 元组类 -> RACOneTuple、RACTwoTuple、RACThreeTuple、RACFourTuple NSLog(@\"%@\",x); }]; } /* 2020-05-28 18:38:30.014387+0800 RACExample[53947:11801545] ( 1, 2 ) */ 3.17. 信号合并:merge(合并) 把多个信号合并为一个信号，任何一个信号有新值的时候就会调用 只要有一个信号被发出就会被监听 - (void)viewDidLoad { [super viewDidLoad]; RACReplaySubject * subjectA = [RACReplaySubject subject]; RACReplaySubject * subjectB = [RACReplaySubject subject]; RACReplaySubject * subjectC = [RACReplaySubject subject]; // 三个对象发送信号（只需其中一个或多个发送信号时，合并的 信号对象 都可以在订阅的 block 接收到信息） [subjectC sendNext:@\"CC\"]; [subjectA sendNext:@\"AA\"]; [subjectB sendNext:@\"BB\"]; // 合并两个信号对象变成一个接收信号对象 subjectD , subjectD 订阅 接收 subjectB 和 subjectA 发送的信号,信号输入的顺序和信号merge的顺序有关联。 [[[subjectB merge:subjectA] merge:subjectC] subscribeNext:^(id _Nullable x) { NSLog(@\"%@\",x); }]; } /* 2020-05-28 14:16:49.377200+0800 RACExample[44542:11640972] BB 2020-05-28 14:16:49.377353+0800 RACExample[44542:11640972] AA 2020-05-28 14:16:49.377509+0800 RACExample[44542:11640972] CC */ 3.18. 信号拼接:then(连接) 使用then连接信号，上一个信号完成后，才会连接then返回的信号，所以then连接的上一个信号必须使用sendCompleted，否则后续信号无法执行。 then连接的多个信号与concat不同的是：之前的信号会被忽略掉，即订阅信号只会接收到最后一个信号的值。 [[RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NSLog(@\"signalOne\"); [subscriber sendNext:@\"signalOne\"]; [subscriber sendCompleted]; return nil; }] subscribeNext:^(id _Nullable x) { NSLog(@\"信号被激活:%@\",x); }]; /* 2020-06-08 18:28:17.835711+0800 RACExample[52619:427692] signalOne 2020-06-08 18:28:17.836206+0800 RACExample[52619:427692] 信号被激活:signalOne */ 添加一个then信号： [[[[RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NSLog(@\"signalOne\"); [subscriber sendNext:@\"signalOne\"]; [subscriber sendCompleted]; return nil; }] then:^RACSignal * _Nonnull{ return [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NSLog(@\"signalTwo\"); [subscriber sendNext:@\"signalTwo\"]; [subscriber sendCompleted]; return nil; }]; }] then:^RACSignal * _Nonnull{ return [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NSLog(@\"signalThree\"); [subscriber sendNext:@\"signalThree\"]; [subscriber sendCompleted]; return nil; }]; }] subscribeNext:^(id _Nullable x) { NSLog(@\"信号被激活:%@\",x); }]; /* 2020-06-08 18:34:42.158566+0800 RACExample[52963:432992] signalOne 2020-06-08 18:34:42.159054+0800 RACExample[52963:432992] signalTwo 2020-06-08 18:34:42.159283+0800 RACExample[52963:432992] signalThree 2020-06-08 18:34:42.159633+0800 RACExample[52963:432992] 信号被激活:signalThree */ 3.19. 信号拼接:concat(合并) 使用concat可以按序拼接多个信号，拼接后的信号按序执行。 只有前面的信号执行sendCompleted，后面的信号才会被激活。 - (void)viewDidLoad { [super viewDidLoad]; RACSignal *signalOne = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { [subscriber sendNext:@\"signalOne\"]; [subscriber sendCompleted]; return nil; }]; RACSignal *signalTwo = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { [subscriber sendNext:@\"signalTwo\"]; // [subscriber sendCompleted]; return nil; }]; RACSignal *signalThree = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { [subscriber sendNext:@\"signalThree\"]; [subscriber sendCompleted]; return nil; }]; //拼接了三个信号，订阅之后，三个信号依次激活 RACSignal *concatSignal = [[signalOne concat:signalTwo] concat:signalThree]; [concatSignal subscribeNext:^(id _Nullable x) { NSLog(@\"信号被激活:%@\",x); }]; } /* 2020-06-08 18:20:53.103639+0800 RACExample[52202:421372] 信号被激活:signalOne 2020-06-08 18:20:53.103922+0800 RACExample[52202:421372] 信号被激活:signalTwo */ 从上面代码看出signalOne->signalTwo->signalThree按照顺序连接，但是在信号signalTwo中没发送sendCompleted，所以后面的信号signalThree没有被激活。 RACSignal *signalTwo = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { [subscriber sendNext:@\"signalTwo\"]; [subscriber sendCompleted]; return nil; }]; /* 2020-06-08 18:23:40.588477+0800 RACExample[52340:423182] 信号被激活:signalOne 2020-06-08 18:23:40.589093+0800 RACExample[52340:423182] 信号被激活:signalTwo 2020-06-08 18:23:40.589539+0800 RACExample[52340:423182] 信号被激活:signalThree */ 3.20. RACObserve RACObserve : KVO 监听属性内容变化 [RACObserve(self.textLabel, text) subscribeNext:^(id _Nullable x) { NSLog(@\"KVO 监听到 age 内容发生变化 ，变为 %@ , thread = %@\",x,[NSThread currentThread]); }]; 3.21. 其他使用 replay重放：当一个信号被多次订阅,反复播放内容 4. RACCommand RACCommand：处理事件的操作,和UI关联.(主线程中执行)，最常用于两个地方，监听按钮点击，网络请求。 @property (nonatomic, strong, readonly) RACSignal *> *executionSignals; @property (nonatomic, strong, readonly) RACSignal *executing; @property (nonatomic, strong, readonly) RACSignal *enabled; @property (nonatomic, strong, readonly) RACSignal *errors; @property (atomic, assign) BOOL allowsConcurrentExecution; - (instancetype)initWithSignalBlock:(RACSignal * (^)(InputType _Nullable input))signalBlock; // 初始化RACCommand的入参enabledSignal就决定了RACCommand是否能开始执行。入参enabledSignal就是触发条件。 - (instancetype)initWithEnabled:(nullable RACSignal *)enabledSignal signalBlock:(RACSignal * (^)(InputType _Nullable input))signalBlock; - (RACSignal *)execute:(nullable InputType)input; executionSignals:是一个高阶信号，所以在使用的时候需要进行降阶操作(flatten，switchToLatest，concat)，降阶的方式根据需求来选取。一般选择的原则：一般不允许并发(dispatch_queue_concurrent)的RACCommand使用switchToLatest，允许并发的使用flatten。 executing:表示了当前RACCommand是否在执行，信号里面的值都是BOOL类型的。YES表示的是RACCommand正在执行过程中，命名也说明的是正在进行时ing。NO表示的是RACCommand没有被执行或者已经执行结束。 enabled: 信号就是一个开关，判断RACCommand是否可用: RACCommand 初始化传入的enabledSignal信号，如果返回NO，那么enabled信号就返回NO。 RACCommand开始执行中，allowsConcurrentExecution为NO，那么enabled信号就返回NO。 除去以上2种情况以外，enabled信号基本都是返回YES。 errors: 信号就是RACCommand执行过程中产生的错误信号。 在对RACCommand进行错误处理的时候，我们不应该使用subscribeError:对RACCommand的executionSignals 进行错误的订阅，因为executionSignals这个信号是不会发送error事件的。 // 用subscribeNext:去订阅错误信号。 [commandSignal.errors subscribeNext:^(NSError *x) { NSLog(@\"ERROR! --> %@\",x); }]; allowsConcurrentExecution: 用来表示当前RACCommand是否允许并发执行。默认值是NO。按照上面说的则enabled的值也会为NO。 allowsConcurrentExecution在具体实现中是用的volatile原子的操作，在实现中重写了它的get和set方法。 // 重写 get方法 - (BOOL)allowsConcurrentExecution { return _allowsConcurrentExecution != 0; } // 重写 set方法 - (void)setAllowsConcurrentExecution:(BOOL)allowed { [self willChangeValueForKey:@keypath(self.allowsConcurrentExecution)]; if (allowed) { // OSAtomicOr32Barrier是原子运算，它的意义是进行逻辑的“或”运算。通过原子性操作访问被volatile修饰的_allowsConcurrentExecution对象即可保障函数只执行一次。 OSAtomicOr32Barrier(1, &_allowsConcurrentExecution); } else { // OSAtomicAnd32Barrier是原子运算，它的意义是进行逻辑的“与”运算。 OSAtomicAnd32Barrier(0, &_allowsConcurrentExecution); } [self didChangeValueForKey:@keypath(self.allowsConcurrentExecution)]; } initWithSignalBlock:与initWithEnabled:signalBlock:的区别： - (instancetype)initWithSignalBlock:(RACSignal * (^)(id input))signalBlock { return [self initWithEnabled:nil signalBlock:signalBlock];// nil 相当于：[RACSignal return:@YES] } 4.1. 使用 RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(NSNumber * _Nullable input) { return [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NSLog(@\"发送信号：%@\",input);//2 [subscriber sendNext:input]; [subscriber sendError:[NSError errorWithDomain:@\"\" code:0 userInfo:@{NSLocalizedDescriptionKey:@\"----\"}]]; [subscriber sendCompleted]; return nil; }]; }]; [command.executionSignals subscribeNext:^(id _Nullable x) { NSLog(@\"收到信号(subscribeNext)：%@\",x);// 我们可以在这里把处理事件(网络请求、逻辑处理)之前的逻辑(showHUD...)放到这。 [x subscribeNext:^(id _Nullable x) { NSLog(@\"x-收到信号(subscribeNext)：%@\",x);// 收到信号B：1 } error:^(NSError * _Nullable error) { NSLog(@\"x-收到信号(error)：%@\",x);//收不到error，因为 executionSignals 不会处理 error } completed:^{ NSLog(@\"x-收到信号(completed)\"); }]; } error:^(NSError * _Nullable error) { NSLog(@\"收到信号(error)：%@\",error.localizedDescription);//收不到error，因为 executionSignals 不会处理 error } completed:^{ NSLog(@\"收到信号(completed)\"); }]; [command execute:@1]; /* 收到信号(subscribeNext)： name: 发送信号：1 x-收到信号(subscribeNext)：1 x-收到信号(completed) 收到信号(completed) */ 换一种方式进行信号处理： RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(NSNumber * _Nullable input) { return [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NSLog(@\"发送信号：%@\",input);//2 [subscriber sendNext:input]; [subscriber sendError:[NSError errorWithDomain:@\"\" code:0 userInfo:@{NSLocalizedDescriptionKey:@\"----\"}]]; [subscriber sendCompleted]; return nil; }]; }]; // 通过 switchToLatest 把高阶信号降阶处理。 [[command.executionSignals switchToLatest] subscribeNext:^(id _Nullable x) { NSLog(@\"收到信号(switchToLatest)：%@\",x); }]; [command.errors subscribeNext:^(NSError * _Nullable x) { NSLog(@\"收到信号(errors)：%@\",x.localizedDescription); }]; [command.executing subscribeNext:^(NSNumber * _Nullable x) { if([x boolValue] == YES){ NSLog(@\"RACCommand命令正在执行...\"); }else{ NSLog(@\"RACCommand命令不在执行中！！！\"); } }]; [command execute:@1]; /* RACCommand命令不在执行中！！！ RACCommand命令正在执行... 我们对executing进行一下处理，去掉无用的触发。 [[[command.executing skip:1] take:1] subscribeNext:^(NSNumber * _Nullable x) { if([x boolValue] == YES){ NSLog(@\"RACCommand命令正在执行...\"); }else{ NSLog(@\"RACCommand命令不在执行中！！！\"); } }]; /* 2020-06-08 17:00:00.488046+0800 RACExample[49056:380458] RACCommand命令正在执行... 2020-06-08 17:00:00.488513+0800 RACExample[49056:380458] 发送信号：1 2020-06-08 17:00:00.488740+0800 RACExample[49056:380458] 收到信号(switchToLatest)：1 2020-06-08 17:00:00.489372+0800 RACExample[49056:380458] 收到信号(errors)：---- */ 或者直接订阅信号： [[command execute:@1] subscribeNext:^(id _Nullable x) { NSLog(@\"接收信号(subscribeNext)：%@\",x); } error:^(NSError * _Nullable error) { NSLog(@\"接收信号(error)：%@\",error.localizedDescription); } completed:^{ NSLog(@\"接收信号(completed)\"); }]; /* 发送信号：1 接收信号(subscribeNext)：1 接收信号(error)：---- */ 5. RACChannel 5.1. RACChannel实现双向绑定 6. Foundation 涉及Foundation相关的RAC分类:NSArray、NSData、NSDictionary、NSEnumerator、NSFileHandle、NSIndexSet、NSInvocation、NSNotificationCenter、NSObject、NSOrderedSet、NSSet、NSString、NSURLConnection、NSUserDefaults。 NSArray+RACSequenceAdditions.h NSData+RACSupport.h NSDictionary+RACSequenceAdditions.h NSEnumerator+RACSequenceAdditions.h NSFileHandle+RACSupport.h NSIndexSet+RACSequenceAdditions.h NSInvocation+RACTypeParsing.h NSNotificationCenter+RACSupport.h NSObject+RACDeallocating.h NSObject+RACDescription.h NSObject+RACKVOWrapper.h NSObject+RACLifting.h NSObject+RACPropertySubscribing.h NSObject+RACSelectorSignal.h NSOrderedSet+RACSequenceAdditions.h NSSet+RACSequenceAdditions.h NSString+RACKeyPathUtilities.h NSString+RACSequenceAdditions.h NSString+RACSupport.h NSURLConnection+RACSupport.h NSUserDefaults+RACSupport.h 6.1. NSObject NSObject+RACDeallocating.h NSObject+RACDescription.h NSObject+RACKVOWrapper.h NSObject+RACLifting.h NSObject+RACPropertySubscribing.h NSObject+RACSelectorSignal.h 6.1.1. NSObject+RACLifting 等待成所有的 RACSignal 对象发送完信号再执行方法) (主程中执行) - (RACSignal *)rac_liftSelector:(SEL)selector withSignals:(RACSignal *)firstSignal, ... NS_REQUIRES_NIL_TERMINATION; - (RACSignal *)rac_liftSelector:(SEL)selector withSignalsFromArray:(NSArray *)signals; - (RACSignal *)rac_liftSelector:(SEL)selector withSignalOfArguments:(RACSignal *)arguments; - (IBAction)test_rac_lift:(id)sender { RACSignal * signalOne = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { // 现在想发出信号了 [subscriber sendNext:@\"网络请求数据 1\"]; // 不需要释放操作 return nil ; }]; RACSignal * signalTwo = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { // 现在想发出信号了 [subscriber sendNext:@\"网络请求数据 2\"]; // 不需要释放操作 return nil ; }]; [self rac_liftSelector:@selector(updateUIWithSignalOneMessage:signalTwoMessage:) withSignalsFromArray:@[signalOne,signalTwo]]; } // 当所有数据都拿到手后更新UI , 传的数据就是 signalOne 和 signalTwo 发出来的信号数据 ，(所以当前设计的接收方法 也必需要有两个参数，发出的信号按顺序 传参) // 假如当前对象方法只设计 传一个参数，那么就会导致崩溃 -(void)updateUIWithSignalOneMessage:(id)signalOneMessage signalTwoMessage:(id)signalTwoMessage{ NSLog(@\"signalOneMessage = %@ , signalTwoMessage = %@ , thread = %@\",signalOneMessage,signalTwoMessage,[NSThread currentThread]); } //signalOneMessage = 网络请求数据 1 , signalTwoMessage = 网络请求数据 2 , thread = {number = 1, name = main} 6.2. NSNotificationCenter RAC 把监听通知的方法改成了 block 形式 // NSNotificationCenter+RACSupport.h - (RACSignal *)rac_addObserverForName:(nullable NSString *)notificationName object:(nullable id)object; - (IBAction)test_rac_addObserverForName:(id)sender { [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardDidHideNotification object:nil] subscribeNext:^(NSNotification * _Nullable x) { NSLog(@\"NSNotification 1 x = %@\",x.userInfo); }]; [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardDidHideNotification object:nil] subscribeNext:^(NSNotification * _Nullable x) { NSLog(@\"NSNotification 2 x = %@\",x.userInfo); }]; [[NSNotificationCenter defaultCenter] postNotificationName:UIKeyboardDidHideNotification object:nil]; // NSNotification 1 x = (null) // NSNotification 2 x = (null) } 6.3. NSString NSString+RACKeyPathUtilities.h NSString+RACSequenceAdditions.h NSString+RACSupport.h 7. UIKit 涉及UIKit相关的RAC分类：UIActionSheet、UIAlertView、UIBarButtonItem、UIButton、UICollectionReusableView、UIControl、UIControl、UIDatePicker、UIGestureRecognizer、UIImagePickerController、UIRefreshControl、UISegmentedControl、UISlider、UIStepper、UISwitch、UITableViewCell、UITableViewHeaderFooterView、UITextField、UITextView。 UIActionSheet+RACSignalSupport.h UIAlertView+RACSignalSupport.h UIBarButtonItem+RACCommandSupport.h UIButton+RACCommandSupport.h UICollectionReusableView+RACSignalSupport.h UIControl+RACSignalSupport.h UIControl+RACSignalSupportPrivate.h UIDatePicker+RACSignalSupport.h UIGestureRecognizer+RACSignalSupport.h UIImagePickerController+RACSignalSupport.h UIRefreshControl+RACCommandSupport.h UISegmentedControl+RACSignalSupport.h UISlider+RACSignalSupport.h UIStepper+RACSignalSupport.h UISwitch+RACSignalSupport.h UITableViewCell+RACSignalSupport.h UITableViewHeaderFooterView+RACSignalSupport.h UITextField+RACSignalSupport.h UITextView+RACSignalSupport.h 7.1. UIControl+RACSignalSupportPrivate - (RACChannelTerminal *)rac_channelForControlEvents:(UIControlEvents)controlEvents key:(NSString *)key nilValue:(nullable id)nilValue; // 按钮点击响应 [[self.loginButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) { }]; 7.2. UITextField+RACSignalSupport - (RACSignal *)rac_textSignal; - (RACChannelTerminal *)rac_newTextChannel; - (void)viewDidLoad { [super viewDidLoad]; @weakify(self) [[self.textField rac_textSignal] subscribeNext:^(NSString * _Nullable x) { @strongify(self) NSLog(@\"text = %@ , textField.text = %@ , thread = %@\",x,self.textField.text,[NSThread currentThread]); }]; RAC(self.textLabel,text) = self.textField.rac_textSignal; } 8. 信号相关类 RACDynamicSignal.h RACEmptySignal.h RACErrorSignal.h RACGroupedSignal.h RACReturnSignal.h RACSignal+Operations.h RACSignal.h RACSignalProvider.d RACSignalSequence.h 9. Disposable NSObject : rac_deallocDisposable NSObject : rac_willDeallocSignal UITableViewCell : rac_prepareForReuseSignal 10. Tips @interface HomeViewModel : NSObject @property (nonatomic, copy) NSString *searchConditons; @property (nonatomic, strong, readonly) RACSignal *searchBtnEnableSignal; @end @implementation HomeViewModel -(instancetype)init{ if (self = [super init]) { [self setUp]; } return self; } - (void)setUp{ [self setupSearchBtnEnableSignal]; } - (void)setupSearchBtnEnableSignal { _searchBtnEnableSignal = [RACSignal combineLatest:@[RACObserve(self, searchConditons)] reduce:^id(NSString *searchConditions){ return @(searchConditions.length); }]; } @end // ===================================================== @interface MovieViewModel : NSObject @property (nonatomic, strong, readonly) RACCommand *requestCommand; @property (nonatomic, copy, readonly) NSArray *movies; @end @implementation MovieViewModel -(instancetype)init{ if (self = [super init]) { [self setup]; } return self; } - (void)setup { _requestCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id _Nullable input) { NSLog(@\"%@\", input); RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NetworkManager *manager = [NetworkManager manager]; [manager getDataWithUrl:@\"https://api.douban.com/v2/movie/search\" parameters:input success:^(id json) { [subscriber sendNext:json]; [subscriber sendCompleted]; } failure:^(NSError *error) { }]; return nil; }]; return [requestSignal map:^id _Nullable(id _Nullable value) { NSMutableArray *dictArray = value[@\"subjects\"]; NSArray *modelArray = [dictArray.rac_sequence map:^id(id value) { return [Movie movieWithDict:value]; }].array; NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@\"year\" ascending:NO]; _movies = [modelArray sortedArrayUsingDescriptors:@[sortDescriptor]]; NSLog(@\"%@\",_movies.description); return nil; }]; }]; } @end 在两个VM中，一个用的是RACSignal，一个用的是RACCommand： RACSignal是单向的，就像1个人在做演讲，观众听到就结束了 RACCommand是双向的，演讲者做演讲，下面的观众听到后还反馈了意见，而演讲者对反馈还做了回复。(V中发出命令，VM收到命令后进行网络请求，并将获取的网络数据包发送出去，V对收到的数据进行解析和显示)。 11. RAC&MVVM开发规约 11.1. VM层 // =============================.h============================= @interface WLMSelectedApplyMerchantVM :NSObject @property (nonatomic, strong, readonly) RACCommand *requestCommand; @property (strong, nonatomic, readonly) RACSubject *messageSubject; @end // =============================.m============================= @interface WLMSelectedApplyMerchantVM() @property (nonatomic, strong, readwrite) RACCommand *requestCommand; @property (strong, nonatomic, readwrite) RACSubject *messageSubject; @end @implementation WLMSelectedApplyMerchantVM #pragma mark - Init -(instancetype)init{ if (self = [super init]) { [self racInit]; } return self; } -(void)dealloc{ [self.requestCommand rac_deallocDisposable]; [self.messageSubject rac_deallocDisposable]; } - (void)racInit { //@weakify(self); _requestCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id _Nullable input) { return [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { //@strongify(self); // Code here... return [RACDisposable disposableWithBlock:^{ }]; }]; }]; } #pragma mark - Publish Methods #pragma mark - Private Methods #pragma mark - Getter -(RACSubject *)messageSubject{ if (!_messageSubject) { _messageSubject = [RACSubject subject]; } return _messageSubject; } #pragma mark - Stter @end 11.2. V层 11.2.1. Controller // =============================.h============================= @interface LoginViewController : UIViewController - (instancetype)initWithViewModel:(RACAndMVVMViewModel*)viewModel; @end // =============================.m============================= @interface LoginViewController () @property(nonatomic, strong) RACAndMVVMViewModel *viewModel; @end @implementation LoginViewController #pragma mark - life cycle - (instancetype)initWithViewModel:(RACAndMVVMViewModel*)viewModel{ if (self == [super init]) { _viewModel = viewModel; } return self; } - (void)viewDidLoad { [super viewDidLoad]; [self segInitViews]; [self bindViewModel]; } #pragma mark - Init Views -(void)segInitViews{} #pragma mark - Layout - (void)updateViewConstraints { [super updateViewConstraints]; } #pragma mark - Private Methods #pragma mark - RAC Data Binding - (void)bindViewModel {} #pragma mark - getter -(RACAndMVVMViewModel *)viewModel{ if (!_viewModel) { _viewModel = [[RACAndMVVMViewModel alloc]init]; } return _viewModel; } #pragma mark setter @end 有些方案会把Controller中的View也自定义出来，成为主View，具体样例： VM层： #pragma mark - ====================VM层==================== @interface LoginMainViewModel : NSObject // Demo RACSubject @property (nonatomic, strong) RACSubject *pushSubject; @end @implementation LoginMainViewModel #pragma mark - Init -(instancetype)init{ if (self = [super init]) { [self racInit]; } return self; } #pragma mark - business - (void)racInit {} #pragma mark - getter - (RACSubject *)pushSubject { if (!_pushSubject) { _pushSubject = [RACSubject subject]; } return _pushSubject; } #pragma mark setter @end 主View层： #pragma mark - ====================V层==================== @interface LoginMainView : UIView // Demo Button @property(nonatomic,strong) UIButton* button; @property(nonatomic,strong) LoginMainViewModel* viewModel; - (instancetype)initWithViewModel:(LoginMainViewModel*)viewModel; @end @implementation LoginMainView - (instancetype)initWithViewModel:(LoginMainViewModel*)viewModel { if (self == [super init]) { _viewModel = viewModel; [self segInitViews]; [self updateConstraints]; [self bindViewModel]; } return self; } #pragma mark - Init Views -(void)segInitViews{} #pragma mark - Layout - (void)updateConstraints { [super updateConstraints]; } #pragma mark - Private Methods #pragma mark - RAC Data Binding - (void)bindViewModel { // Demo sendNext [[self.button rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) { [self.viewModel.pushSubject sendNext:@\"1\"]; }]; } #pragma mark - getter -(LoginMainViewModel *)viewModel{ if (!_viewModel) { _viewModel = [[LoginMainViewModel alloc]init]; } return _viewModel; } #pragma mark setter @end Controller层： #pragma mark - ====================V层==================== @interface LoginViewController () @property (nonatomic, strong) LoginMainView *mainView; @property(nonatomic, strong) LoginMainViewModel *viewModel; @end @implementation LoginViewController #pragma mark - life cycle - (void)viewDidLoad { [super viewDidLoad]; [self segInitViews]; [self bindViewModel]; } #pragma mark - Init Views -(void)segInitViews{ [self.view addSubview:self.mainView]; } #pragma mark - Layout - (void)updateViewConstraints { [self.mainView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.mas_equalTo(self.view); }]; [super updateViewConstraints]; } #pragma mark - Private Methods #pragma mark - RAC Data Binding - (void)bindViewModel { // Demo subscribeNext @weakify(self); [self.viewModel.pushSubject subscribeNext:^(id _Nullable x) { @strongify(self); [self.navigationController pushViewController:[UIViewController new] animated:YES]; }]; } #pragma mark - getter - (LoginMainView *)mainView { if (!_mainView) { _mainView = [[LoginMainView alloc] initWithViewModel:self.viewModel]; } return _mainView; } -(LoginMainViewModel *)viewModel{ if (!_viewModel) { _viewModel = [[LoginMainViewModel alloc]init]; } return _viewModel; } #pragma mark setter @end 11.2.2. 自定义UIView @interface LoginTableView: UIView @property(nonatomic,strong) LoginTableViewModel* viewModel; - (instancetype)initWithViewModel:(LoginTableViewModel*)viewModel; @end @implementation LoginTableView - (instancetype)initWithViewModel:(LoginTableViewModel*)viewModel { if (self == [super init]) { _viewModel = viewModel; [self segInitViews]; [self updateConstraints]; [self bindViewModel]; } return self; } #pragma mark - Init Views -(void)segInitViews{} #pragma mark - Layout - (void)updateConstraints { [super updateConstraints]; } #pragma mark - Private Methods #pragma mark - RAC Data Binding - (void)bindViewModel {} #pragma mark - getter -(LoginTableViewModel *)viewModel{ if (!_viewModel) { _viewModel = [[LoginTableViewModel alloc]init]; } return _viewModel; } #pragma mark setter @end 11.2.3. 自定义复用机制UIView 有复用机制的View：UICollectionviewCell、UITableViewCell...,因为有复用机制，会有部份cell不会走init方法，而是直接走cell复用池。 @interface LoginTableViewCell: UITableViewCell @property (strong, nonatomic) NSIndexPath *indexPath; @property(nonatomic,strong) CircleListMainViewCellViewModel* viewModel; +(NSString*)reuseIdentifier; +(CircleListMainViewCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath; @end @implementation LoginTableViewCell #pragma mark - Init Views +(NSString*)reuseIdentifier{ return NSStringFromClass([self class]); } +(CircleListMainViewCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath{ CircleListMainViewCell *cell = [tableView dequeueReusableCellWithIdentifier:[self reuseIdentifier]]; if (!cell) { cell = [[self alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:[self reuseIdentifier]]; } cell.indexPath = indexPath; return cell; } -(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{ if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) { self.selectionStyle = UITableViewCellSelectionStyleNone; [self segInitViews]; [self updateConstraints]; } return self; } -(void)segInitViews{} #pragma mark - Layout - (void)updateConstraints { [super updateConstraints]; } #pragma mark - Private Methods #pragma mark - RAC Data Binding - (void)bindViewModel {} #pragma mark - getter #pragma mark setter -(void)setViewModel:(LoginTableViewCellViewModel *)viewModel{ _viewModel = viewModel; if (!viewModel) return; [self bindViewModel]; } @end 12. MVVM&RAC 12.1. 使用设计 一个V(ViewController也是一个V)对应一个VM，V界面元素属性与 VM 处理后的数据属性绑定。 ViewController对应的VM算是主VM。主 VM 承担了网络请求、点击事件协议、初始化子 VM 并且给子VM的属性赋初值；网络请求成功返回数据过后，主 ViewModel 还需要给子 ViewModel 的属性赋予新的值。 @interface mainViewModel : NSObject @property (nonatomic, strong) MineHeaderViewModel *mineHeaderViewModel; @property (nonatomic, strong) NSArray *dataSorceOfMineTopCollectionViewCell; @property (nonatomic, strong) NSArray *dataSorceOfMineDownCollectionViewCell; @property (nonatomic, strong) RACCommand *autoLoginCommand;//用于网络请求 @property (nonatomic, strong) RACSubject *pushSubject;//相当于协议，这里用于点击事件的代理 @end 12.2. 示例：列表刷新 具体效果： 2020-06-03 14:20:34.431310+0800 RACExample[29796:2244630] refreshDataCommand execute 2020-06-03 14:20:34.464985+0800 RACExample[29796:2244630] executing subscribeNext 2020-06-03 14:20:34.465376+0800 RACExample[29796:2244630] RefreshLoading 2020-06-03 14:20:35.088477+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendNext 2020-06-03 14:20:35.088770+0800 RACExample[29796:2244630] switchToLatest subscribeNext 2020-06-03 14:20:35.092880+0800 RACExample[29796:2244630] RefreshUI 2020-06-03 14:20:35.093239+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendCompleted 2020-06-03 14:20:37.458024+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendNext 2020-06-03 14:20:37.458241+0800 RACExample[29796:2244630] switchToLatest subscribeNext 2020-06-03 14:20:37.458642+0800 RACExample[29796:2244630] RefreshUI 2020-06-03 14:20:37.458772+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendCompleted 2020-06-03 14:20:38.549670+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendNext 2020-06-03 14:20:38.549901+0800 RACExample[29796:2244630] switchToLatest subscribeNext 2020-06-03 14:20:38.550304+0800 RACExample[29796:2244630] RefreshUI 2020-06-03 14:20:38.550600+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendCompleted 2020-06-03 14:20:40.055668+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendNext 2020-06-03 14:20:40.055887+0800 RACExample[29796:2244630] switchToLatest subscribeNext 2020-06-03 14:20:40.056336+0800 RACExample[29796:2244630] RefreshUI 2020-06-03 14:20:40.056514+0800 RACExample[29796:2244630] refreshDataCommand subscriber sendCompleted 他们的项目结构： ├── Controller │ ├── CircleListViewController.h │ └── CircleListViewController.m ├── Model │ ├── DouBanTheatersModel.h │ └── DouBanTheatersModel.m ├── View │ ├── CircleListMainView.h │ ├── CircleListMainView.m │ ├── CircleListMainViewCell.h │ └── CircleListMainViewCell.m └── ViewModel ├── CircleListMainViewCellViewModel.h ├── CircleListMainViewCellViewModel.m ├── CircleListMainViewModel.h └── CircleListMainViewModel.m 12.2.1. CircleListViewController @interface CircleListViewController () @property (nonatomic, strong) CircleListMainView *mainView; @property(nonatomic, strong) CircleListMainViewModel *viewModel; @end @implementation CircleListViewController #pragma mark - life cycle - (void)viewDidLoad { [super viewDidLoad]; [self segInitViews]; [self bindViewModel]; } #pragma mark - Init Views -(void)segInitViews{ [self.view addSubview:self.mainView]; } #pragma mark - Layout - (void)updateViewConstraints { [self.mainView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.mas_equalTo(self.view); }]; [super updateViewConstraints]; } #pragma mark - Private Methods #pragma mark - RAC Data Binding - (void)bindViewModel { // 点击 cell 跳转 Controller @weakify(self); [[self.viewModel.cellClickSubject takeUntil:self.rac_willDeallocSignal] subscribeNext:^(CircleListMainViewCellViewModel* _Nullable x) { @strongify(self); UIViewController *VC = [UIViewController new]; VC.view.backgroundColor = [UIColor whiteColor]; [self.navigationController pushViewController:VC animated:YES]; }]; } #pragma mark - getter - (CircleListMainView *)mainView { if (!_mainView) { _mainView = [[CircleListMainView alloc] initWithViewModel:self.viewModel]; } return _mainView; } -(CircleListMainViewModel *)viewModel{ if (!_viewModel) { _viewModel = [[CircleListMainViewModel alloc]init]; } return _viewModel; } #pragma mark setter @end 12.2.2. ViewModel CircleListMainViewModel typedef enum : NSUInteger { RefreshLoading, // 正在刷新 RefreshError, // 刷新出错 RefreshUI, // 仅仅刷新UI布局 } RefreshDataStatus; @interface CircleListMainViewModel : NSObject @property (nonatomic, strong) RACCommand *refreshDataCommand; @property (nonatomic, strong) RACSubject *refreshDataSubject; @property (nonatomic, strong) RACSubject *cellClickSubject;//点击cell的热信号 @property (nonatomic, strong,readonly) NSArray *dataArray; @end // ============================.m========================== @interface CircleListMainViewModel() @property (nonatomic, strong) HttpManager *httpManager; @property (nonatomic, strong,readwrite) NSArray *dataArray; @end implementation CircleListMainViewModel #pragma mark - Init -(instancetype)init{ if (self = [super init]) { [self racInit]; } return self; } #pragma mark - business - (void)racInit { // 初始化 RACCommand ，并发起网络请求。 _refreshDataCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id _Nullable input) { return [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { // 网络请求 NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@\"apikey\"] = @\"0df993c66c0c636e29ecbb5344252a4a\"; [self.httpManager requestNetworkDataWithUrlString:@\"/v2/movie/in_theaters\" Params:parameters completed:^(id _Nonnull response, NSError * _Nonnull error) { if (error) { NSLog(@\"refreshDataCommand subscriber sendError\"); [subscriber sendError:error]; }else{ NSLog(@\"refreshDataCommand subscriber sendNext\"); [subscriber sendNext:response]; } NSLog(@\"refreshDataCommand subscriber sendCompleted\"); [subscriber sendCompleted]; }]; return [RACDisposable disposableWithBlock:^{ }]; }]; }]; // 信号流：O-O-O-O-O-O，而下面这段就是,跳过第一个信号，并且只执行一次。 [[[_refreshDataCommand.executing skip:1] take:1] subscribeNext:^(NSNumber * _Nullable x) { NSLog(@\"executing subscribeNext\"); [self showStatus:@\"正在加载...\"]; }]; // 进行业务处理 [[[_refreshDataCommand executionSignals] switchToLatest] subscribeNext:^(NSDictionary* _Nullable response) { NSLog(@\"switchToLatest subscribeNext\"); if (!response) { [self showErrorStatus:@\"网络有问题！\"]; return; } // 把 BO 数据转成 VM NSMutableArray*tempt = [NSMutableArray array]; NSArray *subjects = [response valueForKey:@\"subjects\"]; for (NSDictionary *object in subjects) {; CircleListMainViewCellViewModel *cellViewModel = [[CircleListMainViewCellViewModel alloc] init]; cellViewModel.model = [DouBanTheatersModel yy_modelWithJSON:object]; [tempt addObject:cellViewModel]; } self.dataArray = [NSArray arrayWithArray:tempt]; [self showMessage:@\"请求成功！\"]; }]; // 错误处理 [_refreshDataCommand.errors subscribeNext:^(NSError * _Nullable x) { NSLog(@\"errors subscribeNext\"); [self showErrorStatus:@\"网络有问题！\"]; }]; } -(void)showMessage:(NSString*)message{ [self.refreshDataSubject sendNext:@{@\"code\":@(RefreshUI),@\"msg\":message}]; } -(void)showStatus:(NSString*)status{ [self.refreshDataSubject sendNext:@{@\"code\":@(RefreshLoading),@\"msg\":status}]; } -(void)showErrorStatus:(NSString*)error{ [self.refreshDataSubject sendNext:@{@\"code\":@(RefreshError),@\"msg\":error}]; } #pragma mark - getter -(HttpManager *)httpManager{ if (!_httpManager) { _httpManager = [[HttpManager alloc] initWithBaseURLString:@\"https://api.douban.com\"]; } return _httpManager; } -(RACSubject *)refreshDataSubject{ if (!_refreshDataSubject) { _refreshDataSubject = [RACSubject subject]; } return _refreshDataSubject; } -(RACSubject *)cellClickSubject{ if (!_cellClickSubject) { _cellClickSubject = [RACSubject subject]; } return _cellClickSubject; } #pragma mark setter @end CircleListMainViewCellViewModel @interface CircleListMainViewCellViewModel : NSObject @property (strong, nonatomic) DouBanTheatersModel *model; @end @implementation CircleListMainViewCellViewModel #pragma mark - Init -(instancetype)init{ if (self = [super init]) { [self racInit]; } return self; } #pragma mark - business - (void)racInit {} #pragma mark - getter -(DouBanTheatersModel *)model{ if (!_model) { _model = [[DouBanTheatersModel alloc] init]; } return _model; } #pragma mark setter @end 12.2.3. View CircleListMainView @interface CircleListMainView : UIView @property(nonatomic,strong) CircleListMainViewModel* viewModel; - (instancetype)initWithViewModel:(CircleListMainViewModel*)viewModel; @end // ==============================.m================================ @interface CircleListMainView() @property (strong, nonatomic) UITableView *mainTableView; @end @implementation CircleListMainView - (instancetype)initWithViewModel:(CircleListMainViewModel*)viewModel { if (self == [super init]) { self.backgroundColor = self.superview.backgroundColor; _viewModel = viewModel; [self segInitViews]; [self setNeedsUpdateConstraints]; [self updateConstraintsIfNeeded]; [self bindViewModel]; } return self; } #pragma mark - Init Views -(void)segInitViews{ [self addSubview:self.mainTableView]; } #pragma mark - Layout - (void)updateConstraints { [self.mainTableView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self); }]; [super updateConstraints]; } #pragma mark - Private Methods #pragma mark - RAC Data Binding - (void)bindViewModel { [SVProgressHUD setMinimumDismissTimeInterval:1.0]; // 数据请求 NSLog(@\"refreshDataCommand execute\"); [self.viewModel.refreshDataCommand execute:nil]; // 数据刷新 [self.viewModel.refreshDataSubject subscribeNext:^(NSDictionary* _Nullable x) { [self.mainTableView.mj_header endRefreshing]; [self.mainTableView.mj_footer endRefreshing]; [self.mainTableView reloadData]; NSInteger code = [[x valueForKey:@\"code\"] integerValue]; NSString* msg = [x valueForKey:@\"msg\"]; switch (code) { case RefreshLoading: NSLog(@\"RefreshLoading\"); [SVProgressHUD show]; break; case RefreshError: NSLog(@\"RefreshError\"); [SVProgressHUD showErrorWithStatus:msg]; break; case RefreshUI: NSLog(@\"RefreshUI\"); [SVProgressHUD showSuccessWithStatus:msg]; break; default: break; } }]; } #pragma mark - getter -(CircleListMainViewModel *)viewModel{ if (!_viewModel) { _viewModel = [[CircleListMainViewModel alloc]init]; } return _viewModel; } - (UITableView *)mainTableView { if (!_mainTableView) { _mainTableView = [[UITableView alloc] init]; _mainTableView.delegate = self; _mainTableView.dataSource = self; _mainTableView.backgroundColor = self.backgroundColor; _mainTableView.separatorStyle = UITableViewCellSeparatorStyleNone; _mainTableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{ [self.viewModel.refreshDataCommand execute:nil]; }]; _mainTableView.mj_footer = [MJRefreshAutoNormalFooter footerWithRefreshingBlock:^{ [self.viewModel.refreshDataCommand execute:nil]; }]; } return _mainTableView; } #pragma mark - ====================delegate==================== #pragma mark - UITableViewDataSource - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { return 1; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return self.viewModel.dataArray.count; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { CircleListMainViewCell *cell = [CircleListMainViewCell cellWithTableView:tableView indexPath:indexPath]; if (self.viewModel.dataArray.count > indexPath.row) { cell.viewModel = self.viewModel.dataArray[indexPath.row]; } return cell; } #pragma mark - UITableViewDelegate - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath { return 100; } - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { if (self.viewModel.dataArray.count > indexPath.row) { [self.viewModel.cellClickSubject sendNext:self.viewModel.dataArray[indexPath.row]]; } } @end CircleListMainViewCell @interface CircleListMainViewCell : UITableViewCell @property (strong, nonatomic) NSIndexPath *indexPath; @property(nonatomic,strong) CircleListMainViewCellViewModel* viewModel; +(NSString*)reuseIdentifier; +(CircleListMainViewCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath; @end @implementation CircleListMainViewCell #pragma mark - Init Views +(NSString*)reuseIdentifier{ return NSStringFromClass([self class]); } +(CircleListMainViewCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath{ CircleListMainViewCell *cell = [tableView dequeueReusableCellWithIdentifier:[self reuseIdentifier]]; if (!cell) { cell = [[CircleListMainViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:[self reuseIdentifier]]; } cell.indexPath = indexPath; return cell; } -(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{ if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) { [self segInitViews]; [self updateConstraints]; } return self; } -(void)segInitViews{} #pragma mark - Layout - (void)updateConstraints { [super updateConstraints]; } #pragma mark - Private Methods #pragma mark - RAC Data Binding - (void)bindViewModel { self.textLabel.text = self.viewModel.model.title; //RAC(self.textLabel,text) = RACObserve(self.viewModel.model, title); ==> 这个在数据刷新的时候报错！因为KVO的keypath重复绑定。 //RAC(self.textLabel,text) = [RACObserve(self.viewModel.model, title) takeUntil:self.rac_prepareForReuseSignal]; ==> 可以通过这样的方式搞定。 //在cell里面创建的信号加上takeUntil:cell.rac_prepareForReuseSignal，这个是让cell在每次重用的时候都去disposable创建的信号。 } #pragma mark - getter #pragma mark setter -(void)setViewModel:(CircleListMainViewCellViewModel *)viewModel{ _viewModel = viewModel; if (!viewModel) return; [self bindViewModel]; } @end 12.3. TableView&UIButton 在UITableViewCell中有UIButton按钮，点击按钮出发回调，会有如下一种错误场景：刷新数据时，会重复订阅，导致方法多次触发 CircleListMainView: - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { CircleListMainViewCell *cell = [CircleListMainViewCell cellWithTableView:tableView indexPath:indexPath]; if (self.viewModel.dataArray.count > indexPath.row) { cell.viewModel = self.viewModel.dataArray[indexPath.row]; } [cell.viewModel.buttonClickSubject subscribeNext:^(id _Nullable x) { NSLog(@\"raiseButton subscribeNext--%@\",x); }]; return cell; } CircleListMainViewCell: @implementation CircleListMainViewCell #pragma mark - Private Methods #pragma mark - RAC Data Binding - (void)bindViewModel { @weakify(self); [[self.raiseButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) { @strongify(self); [self.viewModel.buttonClickSubject sendNext:self.viewModel.model]; }]; } @end 在UITableViewCell的分类中，有一个属性rac_prepareForReuseSignal，可以解决这一问题。 @implementation CircleListMainViewCell #pragma mark - Private Methods #pragma mark - RAC Data Binding - (void)bindViewModel { @weakify(self); [[[self.raiseButton rac_signalForControlEvents:UIControlEventTouchUpInside] takeUntil:self.rac_prepareForReuseSignal] subscribeNext:^(__kindof UIControl * _Nullable x) { @strongify(self); [self.viewModel.buttonClickSubject sendNext:self.viewModel.model.title]; }]; } @end 12.4. TableView&UITextField RACChannelTo(self.viewModel,leftString) = RACChannelTo(self.leftTextField,text); [RACObserve(self.viewModel,leftString) subscribeNext:^(id _Nullable x) { NSLog(@\"leftString %@\",x); }]; [[self.clickButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) { self.viewModel.leftString = @\"代码设置StringValue\"; }]; 通过RACChannelTo对TextField.txt和VM.leftString进行双向绑定，可以发现，TextField进行键盘输入时，VM.leftString的值不会更新。当通过代码去对VM.leftString进行赋值时，TextField.txt的值更新了。而按照官方的说法就是，UIKIt里面的很多控件本身不支持KVO，而ReactiveCocoa本身是基于KVO实现的，所以就会出现这种双向绑定不成功的现象。 self.valueTextField.rac_newTextChannel : sends values when you type in the text field, but not when you change the text in the text field from code. RACChannelTo(self.valueTextField, text) : sends values when you change the text in the text field from code, but not when you type in the text field. RACChannelTo(self.viewModel,leftString) = self.leftTextField.rac_newTextChannel; 12.4.1. TableViewCell&UITextField #pragma mark - ====================VM层==================== @interface TextFieldAndTableCellViewModel : NSObject @property (copy, nonatomic) NSString *leftString; @property (copy, nonatomic) NSString *rightString; @property (strong, nonatomic) NSArray *dataArray; @end @implementation TextFieldAndTableCellViewModel -(NSArray *)dataArray{ if (!_dataArray) { NSMutableArray *tempt = [NSMutableArray array]; for (NSInteger i = 0; i @property (weak, nonatomic) IBOutlet UITableView *tableView; @property (weak, nonatomic) IBOutlet UITextField *leftTextField; @property (weak, nonatomic) IBOutlet UITextField *rightTextField; @property (weak, nonatomic) IBOutlet UILabel *textLabel; @property (weak, nonatomic) IBOutlet UIButton *clickButton; @property(nonatomic, strong) TextFieldAndTableCellViewModel *viewModel; @end @implementation TextFieldAndTableCellViewController #pragma mark - life cycle - (void)viewDidLoad { [super viewDidLoad]; [self segInitViews]; [self bindViewModel]; [self.tableView reloadData]; } #pragma mark - Init Views -(void)segInitViews{ self.tableView.delegate = self; self.tableView.dataSource = self; } #pragma mark - Layout - (void)updateViewConstraints { [super updateViewConstraints]; } #pragma mark - Private Methods #pragma mark - RAC Data Binding - (void)bindViewModel { [[self.clickButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) { [self.tableView endEditing:YES]; for (TextFieldAndTableViewCellViewModel *object in self.viewModel.dataArray) { NSLog(@\"inputValue %@\",object.inputValue); } }]; } #pragma mark - getter -(TextFieldAndTableCellViewModel *)viewModel{ if (!_viewModel) { _viewModel = [[TextFieldAndTableCellViewModel alloc]init]; } return _viewModel; } #pragma mark setter #pragma mark - ====================delegate==================== #pragma mark - UITableViewDataSource - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { return 1; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return self.viewModel.dataArray.count; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { TextFieldAndTableViewCell *cell = [TextFieldAndTableViewCell cellWithTableView:tableView indexPath:indexPath]; cell.viewModel = self.viewModel.dataArray[indexPath.row]; return cell; } #pragma mark - UITableViewDelegate - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath { return 50; } @end @interface TextFieldAndTableViewCell : UITableViewCell @property (strong, nonatomic) UITextField *inputTextField; @property (strong, nonatomic) NSIndexPath *indexPath; @property(nonatomic,strong) TextFieldAndTableViewCellViewModel* viewModel; +(NSString*)reuseIdentifier; +(TextFieldAndTableViewCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath; @end @implementation TextFieldAndTableViewCell #pragma mark - Init Views +(NSString*)reuseIdentifier{ return NSStringFromClass([self class]); } +(TextFieldAndTableViewCell*)cellWithTableView:(UITableView*)tableView indexPath:(NSIndexPath*)indexPath{ TextFieldAndTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:[self reuseIdentifier] forIndexPath:indexPath]; if (!cell) { cell = [[TextFieldAndTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:[self reuseIdentifier]]; } cell.indexPath = indexPath; return cell; } -(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{ if (self == [super initWithStyle:style reuseIdentifier:reuseIdentifier]) { [self segInitViews]; [self updateConstraints]; } return self; } -(void)segInitViews{ [self.contentView addSubview:self.inputTextField]; } #pragma mark - Layout - (void)updateConstraints { [self.inputTextField mas_makeConstraints:^(MASConstraintMaker *make) { make.left.top.equalTo(self.contentView).mas_offset(5); make.right.bottom.equalTo(self.contentView).mas_offset(-5); }]; [super updateConstraints]; } #pragma mark - Private Methods #pragma mark - RAC Data Binding - (void)bindViewModel { self.inputTextField.text = self.viewModel.inputValue; self.inputTextField.tag = self.viewModel.tag; @weakify(self) [[[[self.inputTextField rac_textSignal] takeUntil:self.rac_prepareForReuseSignal] filter:^BOOL(NSString * _Nullable value) { NSLog(@\"filter -- %@\", value); return YES; }] subscribeNext:^(NSString * _Nullable x) { @strongify(self); NSLog(@\"subscribeNext %@ tag:%zd\",x,self.inputTextField.tag); self.viewModel.inputValue = x; }]; } #pragma mark - getter #pragma mark setter -(void)setViewModel:(TextFieldAndTableViewCellViewModel *)viewModel{ _viewModel = viewModel; if (!viewModel) return; [self bindViewModel]; } -(UITextField *)inputTextField{ if (!_inputTextField) { _inputTextField = [[UITextField alloc] init]; _inputTextField.font = [UIFont systemFontOfSize:16]; _inputTextField.textColor = [UIColor blackColor]; _inputTextField.tintColor = [UIColor blackColor]; } return _inputTextField; } @end @interface TextFieldAndTableViewCellViewModel : NSObject @property (nonatomic, copy) NSString *inputValue; @property (nonatomic, assign) NSInteger tag; @end @implementation TextFieldAndTableViewCellViewModel #pragma mark - Init -(instancetype)init{ if (self = [super init]) { [self racInit]; } return self; } #pragma mark - business - (void)racInit { } #pragma mark - getter #pragma mark setter @end 12.5. 示例：登录 /*================================================宏================================================*/ #define GreenBgColor [UIColor colorWithRed:0.8 green:1.0 blue:0.8 alpha:1] #define RedBgColor [UIColor colorWithRed:1.0 green:0.8 blue:0.8 alpha:1] #define WhiteBgColor [UIColor whiteColor] #define ConvertInputStateToColor(signal) [InputStateToColorConverter convert:signal] #define ConvertTextToInputState(signal, minimum, maximum) [TextToInputStateConverter convert:signal m##inimum:minimum m##aximum:maximum] typedef enum : NSUInteger { InputStateEmpty, InputStateValid, InputStateInvalid } InputState; /*================================================V层-InputStateToColorConverter================================================*/ @interface InputStateToColorConverter : NSObject + (RACSignal *)convert:(RACSignal *)signal; @end @implementation InputStateToColorConverter + (RACSignal *)convert:(RACSignal *)signal{ return [signal map:^id(NSNumber *inputStateNumber) { InputState inputState = [inputStateNumber unsignedIntegerValue]; switch (inputState) { case InputStateValid: return GreenBgColor; case InputStateInvalid: return RedBgColor; default: return WhiteBgColor; } }]; } @end /*================================================V层-TextToInputStateConverter================================================*/ @interface TextToInputStateConverter : NSObject + (RACSignal *)convert:(RACSignal *)signal minimum:(NSInteger)minimum maximum:(NSInteger)maximum; + (InputState)inputStateForText:(NSString *)text minimum:(NSInteger)minimum maximum:(NSInteger)maximum; @end @implementation TextToInputStateConverter + (RACSignal *)convert:(RACSignal *)signal minimum:(NSInteger)minimum maximum:(NSInteger)maximum{ NSAssert(minimum > 0, @\"TextToInputStateConverter: minimum must be greater than zero\"); NSAssert(maximum >= minimum, @\"TextToInputStateConverter: maximum must be greater than or equal to minimum\"); return [signal map:^id(NSString *text) { return @([TextToInputStateConverter inputStateForText:text minimum:minimum maximum:maximum]); }]; } + (InputState)inputStateForText:(NSString *)text minimum:(NSInteger)minimum maximum:(NSInteger)maximum{ if ([text length] >= minimum && [text length] 12.6. 示例：豆瓣列表 #pragma mark - ====================VM层==================== //定义命令、网络请求、获取数据、发送数据 @interface DouBanDetailViewModel : NSObject @property (nonatomic, copy, readonly) NSArray *movies; @property (nonatomic, strong, readonly) RACCommand *requestCommand; @property (nonatomic, strong, readonly) AFHTTPSessionManager *manager; @end @implementation DouBanDetailViewModel #pragma mark - Init -(instancetype)init{ if (self = [super init]) { _manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@\"https://api.douban.com\"]]; [self racInit]; } return self; } #pragma mark - business - (void)racInit { @weakify(self) _requestCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id _Nullable input) { // 网络请求 RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { @strongify(self) [self.manager GET:@\"/v2/movie/in_theaters\" parameters:input progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSLog(@\"sendNext\"); [subscriber sendNext:responseObject]; [subscriber sendCompleted]; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { [subscriber sendError:error]; NSLog(@\"sendError\"); }]; return [RACDisposable disposableWithBlock:^{ NSLog(@\"disposableWithBlock\"); }]; }]; // 业务逻辑处理 return [requestSignal map:^id _Nullable(id _Nullable value) { NSLog(@\"map\"); NSMutableArray *tempt = [NSMutableArray array]; NSMutableArray *dictArray = value[@\"subjects\"]; for (NSDictionary *object in dictArray) { [tempt addObject:[object valueForKey:@\"title\"]]; } self->_movies = [NSArray arrayWithArray:tempt];; return nil; }]; }]; } #pragma mark - getter #pragma mark setter @end #pragma mark - ====================V层==================== @interface DouBanViewDetailController () @property (weak, nonatomic) IBOutlet UITableView *tableView; @property(nonatomic, strong) DouBanDetailViewModel *viewModel; @end @implementation DouBanViewDetailController - (void)viewDidLoad { [super viewDidLoad]; [self segInitViews]; [self bindViewModel]; } #pragma mark - Init Views -(void)segInitViews{ self.tableView.delegate = self; self.tableView.dataSource = self; } #pragma mark - Private Methods #pragma mark - RAC Data Binding - (void)bindViewModel { @weakify(self) [[[self.viewModel.requestCommand executionSignals] switchToLatest] subscribeNext:^(id _Nullable x) { @strongify(self) NSLog(@\"switchToLatest:%@\",x); [self.tableView reloadData]; [SVProgressHUD dismiss]; }]; [self.viewModel.requestCommand.errors subscribeNext:^(NSError * _Nullable x) { NSLog(@\"errors subscribeNext:%@\",x); [SVProgressHUD dismiss]; }]; // 发起网络请求 NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@\"apikey\"] = @\"0df993c66c0c636e29ecbb5344252a4a\"; [self.viewModel.requestCommand execute:parameters]; [SVProgressHUD show]; } // 或者可以这样 - (void)bindViewModel { @weakify(self) [[self.viewModel.requestCommand executionSignals] subscribeNext:^(RACSignal* _Nullable x) { NSLog(@\"subscribeNext1:%@\",x); [SVProgressHUD show]; [x subscribeNext:^(id _Nullable x) { @strongify(self) NSLog(@\"subscribeNext2:%@\",x); [self.tableView reloadData]; [SVProgressHUD dismiss]; }]; }]; [self.viewModel.requestCommand.errors subscribeNext:^(NSError * _Nullable x) { NSLog(@\"errors subscribeNext:%@\",x); [SVProgressHUD dismiss]; }]; // 发起网络请求 NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@\"apikey\"] = @\"0df993c66c0c636e29ecbb5344252a4a\"; [self.viewModel.requestCommand execute:parameters]; } #pragma mark - UITableViewDataSource - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { return 1; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return self.viewModel.movies.count; } -(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{ return 44.0; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { DouBanDetailTableViewCell *cell = [DouBanDetailTableViewCell cellWithTableView:tableView indexPath:indexPath]; cell.textLabel.text = self.viewModel.movies[indexPath.row]; return cell; } #pragma mark - getter -(DouBanDetailViewModel *)viewModel{ if (!_viewModel) { _viewModel = [[DouBanDetailViewModel alloc]init]; } return _viewModel; } #pragma mark setter @end 12.7. RACCommand中的sendError没反应的解答 RAC中用RACCommand处理指令 // 这样使用就可以捕捉到Error了。 [self.viewModel.requestCommand.errors subscribeNext:^(NSError * _Nullable x) { NSLog(@\"errors subscribeNext:%@\",x); }]; 12.8. 示例:多接口请求 @interface DouBanDetailViewModel : NSObject @property (nonatomic, strong, readonly) RACCommand *requestCommand; @end @implementation DouBanDetailViewModel #pragma mark - Init -(instancetype)init{ if (self = [super init]) { [self racInit]; } return self; } #pragma mark - business - (void)racInit { _requestCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id _Nullable input) { //网络请求1 RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id subscriber) { NSLog(@\"网络请求1\"); [subscriber sendNext:@\"网络请求1\"]; return nil; }]; //网络请求2 RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(id subscriber) { NSLog(@\"网络请求2\"); [subscriber sendNext:@\"网络请求2\"]; return nil; }]; //网络请求3 RACSignal *signal3 = [RACSignal createSignal:^RACDisposable *(id subscriber) { NSLog(@\"网络请求3\"); [subscriber sendNext:@\"网络请求3\"]; return nil; }]; return [self rac_liftSelector:@selector(dealDataWithData1:data2:data3:) withSignalsFromArray:@[signal1,signal2,signal3]]; }]; } -(void)dealDataWithData1:(id)data1 data2:(id)data2 data3:(id)data3{} #pragma mark - getter #pragma mark setter @end V层使用： - (void)bindViewModel { // 发起网络请求 NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@\"q\"] = _conditions; parameters[@\"apikey\"] = @\"0df993c66c0c636e29ecbb5344252a4a\"; [self.viewModel.requestCommand execute:parameters]; [SVProgressHUD show]; [self.viewModel.requestCommand.executionSignals.switchToLatest subscribeNext:^(id _Nullable x) { [self.tableView reloadData]; [SVProgressHUD dismiss]; }]; [self.viewModel.requestCommand.executionSignals subscribeError:^(NSError * _Nullable error) { [SVProgressHUD dismiss]; NSLog(@\"subscribeError\"); }]; [[[self.viewModel.requestCommand executing] skip:1] subscribeNext:^(NSNumber * _Nullable x) { }]; } 12.9. 示例：RAC、distinctUntilChanged /*==================================VM层======================================*/ @interface RACAndMVVMViewModel01 : NSObject // KVO TextField输入值 @property (strong, nonatomic) NSString *searchText; //创建一个绑定View的指令.RACCommand是ReactiveCocoa中呈现UI动作的组件.它包含一个来表示UI动作结果、当前状态、标明动作是否被执行的信号量. @property (strong, nonatomic) RACCommand *executeSearch; @end @implementation RACAndMVVMViewModel01 - (instancetype)init { if (self == [super init]) { [self checkSearchText]; } return self; } // 这个方法中将执行一些业务逻辑作为执行命令的结果,并会通过信号异步地返回结果. // 目前只完成了一个虚拟的执行情况;空信号立即完成.延迟操作增加了完成事件返回后的两秒延迟.用来使代码看起来更加真实. - (RACSignal *)executeSearchSignal { return [[[[RACSignal empty] logAll] delay:2.0] logAll]; } // 检查 searchText 输入的合法性 -(void)checkSearchText{ /*[[RACObserve(self, searchText) map:^id _Nullable(NSString* _Nullable value) { return @(value.length > 3); }] subscribeNext:^(id _Nullable x) { NSLog(@\"search text is valid %@\", x); }];*/ // distinctUntilChanged 只有输入合法才能进行打印 RACSignal *validSearchSignal = [[RACObserve(self, searchText) map:^id _Nullable(NSString* _Nullable value) { return @(value.length > 3); }]distinctUntilChanged]; [validSearchSignal subscribeNext:^(id _Nullable x) { NSLog(@\"search text is valid %@\", x); }]; self.executeSearch = [[RACCommand alloc] initWithEnabled:validSearchSignal signalBlock:^RACSignal * _Nonnull(id _Nullable input) { return [self executeSearchSignal]; }]; } /* 2020-05-29 15:57:23.746708+0800 RACExample[90175:12323634] search text is valid 0 2020-05-29 15:57:27.843193+0800 RACExample[90175:12323634] search text is valid 1 2020-05-29 15:57:34.804425+0800 RACExample[90175:12323634] search text is valid 0 */ @end /*==================================V层======================================*/ @interface RACAndMVVMViewController01 () @property (weak, nonatomic) IBOutlet UIButton *loginButton; @property (weak, nonatomic) IBOutlet UITextField *searchTextField; @property (strong, nonatomic) RACAndMVVMViewModel01 *viewModel; @end @implementation RACAndMVVMViewController01 - (void)viewDidLoad { [super viewDidLoad]; [self bindViewModel]; } - (void)bindViewModel { RAC(self.viewModel,searchText) = self.searchTextField.rac_textSignal; self.loginButton.rac_command = self.viewModel.executeSearch; } -(RACAndMVVMViewModel01 *)viewModel{ if (!_viewModel) { _viewModel = [[RACAndMVVMViewModel01 alloc] init]; } return _viewModel; } 当按钮值为Input时，按钮的状态是Disabled，因为输入的内容不合法。 12.10. 示例：发邮件 #pragma mark - ====================VM层==================== @interface RACAndMVVMViewModel02 : NSObject @property(nonatomic, strong) NSString *email; @property(nonatomic, strong) NSString *statusMessage; @property(nonatomic, strong) RACCommand *subscribeCommand; @end @implementation RACAndMVVMViewModel02 -(instancetype)init{ if (self == [super init]) { [self rac_init]; } return self; } -(void)rac_init{ @weakify(self) RACSignal *emailSignal = [[RACObserve(self, email) map:^id _Nullable(NSString* _Nullable value) { @strongify(self) return @([self isValidEmail:value]); }]distinctUntilChanged]; [emailSignal subscribeNext:^(id _Nullable x) { NSLog(@\"%@\",x); }]; self.subscribeCommand = [[RACCommand alloc] initWithEnabled:emailSignal signalBlock:^RACSignal * _Nonnull(id _Nullable input) { @strongify(self) return [self businessOperation:self.email]; }]; RACSignal *rac1 = [self.subscribeCommand.executionSignals map:^id _Nullable(id _Nullable value) { NSLog(@\"Request\"); return @\"Request\"; }]; RACSignal *rac2 = [self.subscribeCommand.executionSignals flattenMap:^__kindof RACSignal * _Nullable(RACSignal* signal) { return [[[signal materialize]filter:^BOOL(RACEvent *event) { NSLog(@\"... RACEventType:%zd\",event.eventType); return event.eventType == RACEventTypeCompleted; }] map:^id _Nullable(id _Nullable value) { NSLog(@\"Thanks!\"); return @\"Thanks!\"; }]; }]; RACSignal *rac3 = [[self.subscribeCommand.errors subscribeOn:[RACScheduler mainThreadScheduler]] map:^id _Nullable(NSError * _Nullable value) { NSLog(@\"Error\"); return @\"Error\"; }]; RAC(self,statusMessage) = [RACSignal merge:@[rac1,rac2,rac3]]; } // 处理业务逻辑 -(RACSignal*)businessOperation:(NSString*)content{ return [RACSignal createSignal:^RACDisposable * _Nullable(id _Nonnull subscriber) { NSLog(@\"Loading...\"); [subscriber sendNext:@\"Loading...\"]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ [subscriber sendError:nil]; }); return [RACDisposable disposableWithBlock:^{ }]; }]; } // 检测strin是否是邮件 - (BOOL)isValidEmail:(NSString*)content { if (!content) return NO; NSString *emailPattern = @\"(?:[a-z0-9!#$%\\\\&'*+/=?\\\\^_`{|}~-]+(?:\\\\.[a-z0-9!#$%\\\\&'*+/=?\\\\^_`{|}\" @\"~-]+)*|\\\"(?:[\\\\x01-\\\\x08\\\\x0b\\\\x0c\\\\x0e-\\\\x1f\\\\x21\\\\x23-\\\\x5b\\\\x5d-\\\\\" @\"x7f]|\\\\\\\\[\\\\x01-\\\\x09\\\\x0b\\\\x0c\\\\x0e-\\\\x7f])*\\\")@(?:(?:[a-z0-9](?:[a-\" @\"z0-9-]*[a-z0-9])?\\\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\\\[(?:(?:25[0-5\" @\"]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-\" @\"9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\\\x01-\\\\x08\\\\x0b\\\\x0c\\\\x0e-\\\\x1f\\\\x21\" @\"-\\\\x5a\\\\x53-\\\\x7f]|\\\\\\\\[\\\\x01-\\\\x09\\\\x0b\\\\x0c\\\\x0e-\\\\x7f])+)\\\\])\"; NSError *error = nil; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:emailPattern options:NSRegularExpressionCaseInsensitive error:&error]; NSTextCheckingResult *match = [regex firstMatchInString:content options:0 range:NSMakeRange(0, [content length])]; return match != nil; } @end #pragma mark - ====================V层==================== @interface RACAndMVVMViewController02 () @property (weak, nonatomic) IBOutlet UITextField *inputTextField; @property (weak, nonatomic) IBOutlet UIButton *loginButton; @property (weak, nonatomic) IBOutlet UILabel *statusLabel; @property(nonatomic, strong) RACAndMVVMViewModel02 *viewModel; @end @implementation RACAndMVVMViewController02 - (void)viewDidLoad { [super viewDidLoad]; [self bindViewModel]; } #pragma mark - Private Methods #pragma mark - RAC Data Binding - (void)bindViewModel { RAC(self.viewModel,email) = self.inputTextField.rac_textSignal; RAC(self.statusLabel,text) = RACObserve(self.viewModel, statusMessage); self.loginButton.rac_command = self.viewModel.subscribeCommand; } #pragma mark - getter -(RACAndMVVMViewModel02 *)viewModel{ if (!_viewModel) { _viewModel = [RACAndMVVMViewModel02 new]; } return _viewModel; } #pragma mark setter @end /* 2020-05-29 16:58:36.155235+0800 RACExample[92708:12365862] 0 2020-05-29 16:58:40.675972+0800 RACExample[92708:12365862] 1 2020-05-29 16:58:43.872743+0800 RACExample[92708:12365862] Request 2020-05-29 16:58:43.873233+0800 RACExample[92708:12365862] Loading... 2020-05-29 16:58:43.873464+0800 RACExample[92708:12365862] ... RACEventType:2 --> 0 = RACEventTypeNext 2020-05-29 16:58:45.874203+0800 RACExample[92708:12365862] ... RACEventType:0 --> 0 = RACEventTypeCompleted 2020-05-29 16:58:45.874431+0800 RACExample[92708:12365862] Thanks! 2020-05-29 16:58:45.876062+0800 RACExample[92708:12365862] Error */ 12.11. 示例：验证码倒计时 VM层： #pragma mark - ====================VM层==================== @interface RASecondsCountViewModel : NSObject @property (nonatomic, strong) RACCommand *requestCommand; @property (nonatomic, assign) BOOL buttonEnabled; @property (nonatomic, copy) NSString *countStirng; @property (nonatomic, assign) NSInteger countTotal; @end @implementation RASecondsCountViewModel #pragma mark - Init -(instancetype)init{ if (self = [super init]) { self.countStirng = @\"获取验证码\"; self.buttonEnabled = YES; self.countTotal = 5; [self racInit]; } return self; } /// 获取验证码逻辑 -(void)secondsCount { [[[[[[RACSubject interval:1 onScheduler:[RACScheduler mainThreadScheduler]] startWith:[NSDate date]] scanWithStart:@(self.countTotal) reduce:^id _Nullable(NSNumber* _Nullable running, NSDate * _Nullable next) { return @( running.integerValue - 1); }] takeUntilBlock:^BOOL(NSNumber* _Nullable x) { return x.integerValue _Nonnull subscriber) { @strongify(self); [self secondsCount]; // 其他业务逻辑，网络请求... [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^{ }]; }]; }]; } @end V层： [[self.countButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) { [self.viewModel.requestCommand execute:nil]; }]; [RACObserve(self.viewModel, countStirng) subscribeNext:^(id _Nullable x) { self.countButton.titleLabel.text = x; [self.countButton setTitle:x forState:UIControlStateNormal]; }]; [RACObserve(self.viewModel, buttonEnabled) subscribeNext:^(NSNumber* _Nullable x) { self.countButton.enabled = [x boolValue]; }]; 13. 资料 Github-ReactiveCocoa 响应式编程（Reactive Programming）介绍 UITextField-RAC使用详解 iOS使用RAC实现MVVM的正经姿势 优雅的 RACCommand http://timmy6.github.io/2019/02/27/MVVM/ "}}